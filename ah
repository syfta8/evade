local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "KOMAT Hub",
    SubTitle = "Evade Hub on top",
    TabWidth = 160,
    Size = UDim2.new(0, 600, 0, 400),
    Position = UDim2.new(0.5, -300, 0.5, -200),
    Theme = "Dark",
    CloseCallback = function()
        print("UI Closed")
    end
})

local MainTab = Window:CreateTab("Main Menu", "bird")
local TeleportTab = Window:CreateTab("Teleport", "bird")
local VisualsTab = Window:CreateTab("Visuals", "bird")
local SettingsTab = Window:CreateTab("Settings", "bird")
local ExtraTab = Window:CreateTab("Extras", "worm")
local FPSTab = Window:CreateTab("FPS", "lock")
local EventTab = Window:CreateTab("Events", "bird")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")
local FloatingGui = PlayerGui:FindFirstChild("EvadeFloatingGui")
if not FloatingGui then
    FloatingGui = Instance.new("ScreenGui")
    FloatingGui.Name = "EvadeFloatingGui"
    FloatingGui.Parent = PlayerGui
    FloatingGui.ResetOnSpawn = false
    FloatingGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
end

-- Variabel global untuk toggle
getgenv().autoBhop = false
local floatingBhopButton

local function createBhopFloatingButton()
    if floatingBhopButton then return end
    floatingBhopButton = Instance.new("TextButton")
    floatingBhopButton.Size = UDim2.new(0,120,0,50)
    floatingBhopButton.Position = UDim2.new(0.3,-60,0.8,0)
    floatingBhopButton.AnchorPoint = Vector2.new(0.5,0)
    floatingBhopButton.BackgroundColor3 = Color3.fromRGB(0,170,255)
    floatingBhopButton.TextColor3 = Color3.fromRGB(255,255,255)
    floatingBhopButton.Text = "Auto Bhop: OFF"
    floatingBhopButton.Parent = FloatingGui
    floatingBhopButton.Active = true
    floatingBhopButton.Draggable = true
    floatingBhopButton.MouseButton1Click:Connect(function()
        getgenv().autoBhop = not getgenv().autoBhop
        floatingBhopButton.Text = getgenv().autoBhop and "Auto Bhop: ON" or "Auto Bhop: OFF"
    end)
end

local function removeBhopFloatingButton()
    if floatingBhopButton then
        floatingBhopButton:Destroy()
        floatingBhopButton = nil
    end
end

MainTab:AddToggle({
    Title = "Auto Bhop (Normal)",
    Description = "Automatically bounce without touching ground",
    Value = false,
    Callback = function(state)
        getgenv().autoBhop = state
    end
})

MainTab:AddToggle({
    Title = "Auto Bhop (Floating Button)",
    Description = "Show floating button for Auto Bhop",
    Value = false,
    Callback = function(state)
        if state then 
            createBhopFloatingButton() 
        else 
            removeBhopFloatingButton() 
            getgenv().autoBhop = false 
        end
    end
})

-- Auto Bhop Loop
task.spawn(function()
    local RunService = game:GetService("RunService")
    local rayDistance = 4
    while true do
        RunService.Heartbeat:Wait()
        if getgenv().autoBhop then
            local char = player.Character
            if char then
                local humanoid = char:FindFirstChildOfClass("Humanoid")
                local root = char:FindFirstChild("HumanoidRootPart")
                if humanoid and root then
                    local rayOrigin = root.Position
                    local rayDir = Vector3.new(0, -rayDistance, 0)
                    local ray = Ray.new(rayOrigin, rayDir)
                    local hit, pos = workspace:FindPartOnRay(ray, char)
                    
                    if hit then
                        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    end
                end
            end
        end
    end
end)

-- Lag Switch
local floatingLagButton
local function lagSwitch(duration)
    local start = tick()
    while tick()-start < duration do
        for i=1,1e7 do local a=math.random() end
    end
end

MainTab:AddButton({
    Title = "Lag Switch (Normal)",
    Description = "Hold for 0.5 seconds lag",
    Callback = function()
        lagSwitch(0.5)
    end
})

local function createLagFloatingButton()
    if floatingLagButton then return end
    floatingLagButton = Instance.new("TextButton")
    floatingLagButton.Size = UDim2.new(0,100,0,50)
    floatingLagButton.Position = UDim2.new(0.7,-50,0.8,0)
    floatingLagButton.AnchorPoint = Vector2.new(0.5,0)
    floatingLagButton.BackgroundColor3 = Color3.fromRGB(255,100,0)
    floatingLagButton.TextColor3 = Color3.fromRGB(255,255,255)
    floatingLagButton.Text = "Lag Switch"
    floatingLagButton.Parent = FloatingGui
    floatingLagButton.Active = true
    floatingLagButton.Draggable = true
    floatingLagButton.MouseButton1Click:Connect(function()
        lagSwitch(0.5)
    end)
end

local function removeLagFloatingButton()
    if floatingLagButton then
        floatingLagButton:Destroy()
        floatingLagButton = nil
    end
end

MainTab:AddToggle({
    Title = "Lag Switch (Floating Button)",
    Description = "Show floating button for Lag Switch",
    Value = false,
    Callback = function(state)
        if state then 
            createLagFloatingButton() 
        else 
            removeLagFloatingButton() 
        end
    end
})

-- Auto Bounce
getgenv().autoBounce = false
local floatingBounceButton
getgenv().bouncePower = 100
local groundCheckDistance = 6

task.spawn(function()
    local RunService = game:GetService("RunService")
    while true do
        if getgenv().autoBounce then
            local char = player.Character
            if char then
                local root = char:FindFirstChild("HumanoidRootPart")
                local humanoid = char:FindFirstChildOfClass("Humanoid")
                if root and humanoid then
                    local rayOrigin = root.Position
                    local rayDirection = Vector3.new(0, -groundCheckDistance, 0)
                    local raycastParams = RaycastParams.new()
                    raycastParams.FilterDescendantsInstances = {char}
                    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                    
                    local ray = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
                    
                    if ray and root.Velocity.Y < 0 then
                        root.Velocity = Vector3.new(root.Velocity.X, getgenv().bouncePower, root.Velocity.Z)
                    end
                end
            end
        end
        task.wait(0.03)
    end
end)

MainTab:AddToggle({
    Title = "Auto Bounce (Normal)",
    Description = "Automatically bounce when falling near ground",
    Value = false,
    Callback = function(state) 
        getgenv().autoBounce = state 
    end
})

local function createBounceFloatingButton()
    if floatingBounceButton then return end
    floatingBounceButton = Instance.new("TextButton")
    floatingBounceButton.Size = UDim2.new(0,100,0,50)
    floatingBounceButton.Position = UDim2.new(0.5,-50,0.85,0)
    floatingBounceButton.AnchorPoint = Vector2.new(0.5,0)
    floatingBounceButton.BackgroundColor3 = Color3.fromRGB(255,0,150)
    floatingBounceButton.TextColor3 = Color3.fromRGB(255,255,255)
    floatingBounceButton.Text = getgenv().autoBounce and "Auto Bounce: ON" or "Auto Bounce: OFF"
    floatingBounceButton.Parent = FloatingGui
    floatingBounceButton.Active = true
    floatingBounceButton.Draggable = true
    floatingBounceButton.MouseButton1Click:Connect(function()
        getgenv().autoBounce = not getgenv().autoBounce
        floatingBounceButton.Text = getgenv().autoBounce and "Auto Bounce: ON" or "Auto Bounce: OFF"
    end)
end

MainTab:AddToggle({
    Title = "Auto Bounce (Floating Button)",
    Description = "Show floating button for Auto Bounce",
    Value = false,
    Callback = function(state)
        if state then 
            createBounceFloatingButton() 
        else
            if floatingBounceButton then 
                floatingBounceButton:Destroy() 
                floatingBounceButton = nil 
            end
            getgenv().autoBounce = false
        end
    end
})

-- Auto Respawn
getgenv().AutoRespawnEnabled = false
getgenv().autoRespawnMethod = "Fake Revive"
local respawnConnection
local lastSavedPosition
local floatingRespawnButton

local function createRespawnFloatingButton()
    if floatingRespawnButton then return end
    floatingRespawnButton = Instance.new("TextButton")
    floatingRespawnButton.Size = UDim2.new(0,120,0,50)
    floatingRespawnButton.Position = UDim2.new(0.8,0,0.8,0)
    floatingRespawnButton.BackgroundColor3 = Color3.fromRGB(255,80,80)
    floatingRespawnButton.TextColor3 = Color3.new(1,1,1)
    floatingRespawnButton.Font = Enum.Font.GothamBold
    floatingRespawnButton.Text = "Auto Respawn"
    floatingRespawnButton.Parent = FloatingGui
    floatingRespawnButton.ZIndex = 10
    floatingRespawnButton.Active = true
    floatingRespawnButton.Draggable = true
    floatingRespawnButton.MouseButton1Click:Connect(function()
        getgenv().AutoRespawnEnabled = not getgenv().AutoRespawnEnabled
        floatingRespawnButton.BackgroundColor3 = getgenv().AutoRespawnEnabled and Color3.fromRGB(80,255,80) or Color3.fromRGB(255,80,80)
    end)
end

local function removeRespawnFloatingButton()
    if floatingRespawnButton then
        floatingRespawnButton:Destroy()
        floatingRespawnButton = nil
    end
end

local function setupAutoRevive(character)
    task.defer(function()
        character:WaitForChild("HumanoidRootPart",5)
        character:WaitForChild("Humanoid",5)
        task.spawn(function()
            while character and character.Parent do
                local hrp = character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    character:SetAttribute("LastPosition", hrp.Position)
                end
                task.wait(0.2)
            end
        end)

        character:GetAttributeChangedSignal("Downed"):Connect(function()
            if not getgenv().AutoRespawnEnabled then return end
            if character:GetAttribute("Downed") ~= true then return end
            if getgenv().autoRespawnMethod ~= "Fake Revive" then return end

            local hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then lastSavedPosition = hrp.Position end

            task.wait(3)
            local start = tick()
            repeat
                pcall(function()
                    game:GetService("ReplicatedStorage"):WaitForChild("Events",9e9)
                        :WaitForChild("Player",9e9)
                        :WaitForChild("ChangePlayerMode",9e9)
                        :FireServer(true)
                end)
                task.wait(1)
            until character:GetAttribute("Downed") ~= true or tick() - start > 1

            local newChar
            repeat
                newChar = game:GetService("Players").LocalPlayer.Character
                task.wait()
            until newChar and newChar:FindFirstChild("HumanoidRootPart")

            local newHRP = newChar:FindFirstChild("HumanoidRootPart")
            if lastSavedPosition and newHRP then
                newHRP.CFrame = CFrame.new(lastSavedPosition)
                task.wait(0.5)
            end
        end)
    end
end)

local player = game:GetService("Players").LocalPlayer
if player.Character then setupAutoRevive(player.Character) end
player.CharacterAdded:Connect(setupAutoRevive)

MainTab:AddToggle({
    Title = "Auto Respawn (Normal)",
    Description = "Auto respawn until turned off",
    Value = false,
    Callback = function(state)
        getgenv().AutoRespawnEnabled = state

        if respawnConnection then
            respawnConnection:Disconnect()
            respawnConnection = nil
        end

        if state then
            if player.Character then setupAutoRevive(player.Character) end
        end
    end
})

MainTab:AddDropdown({
    Title = "Respawn Method",
    Options = {"Random","Fake Revive"},
    Selected = getgenv().autoRespawnMethod,
    Callback = function(option)
        getgenv().autoRespawnMethod = option
    end
})

MainTab:AddToggle({
    Title = "Auto Respawn (Floating Button)",
    Description = "Show floating button for Auto Respawn",
    Value = false,
    Callback = function(state)
        if state then 
            createRespawnFloatingButton() 
        else
            removeRespawnFloatingButton()
            getgenv().AutoRespawnEnabled = false
        end
    end
})

-- Teleport to Roof
local floatingTPButton
local function teleportRoof()
    local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if root then root.CFrame = root.CFrame + Vector3.new(0,500,0) end
end

TeleportTab:AddButton({
    Title = "Teleport to Roof (Normal)",
    Description = "Press to go to roof",
    Callback = teleportRoof
})

local function createTPFloatingButton()
    if floatingTPButton then return end
    floatingTPButton = Instance.new("TextButton")
    floatingTPButton.Size = UDim2.new(0,100,0,50)
    floatingTPButton.Position = UDim2.new(0.5,-50,0.6,0)
    floatingTPButton.AnchorPoint = Vector2.new(0.5,0)
    floatingTPButton.BackgroundColor3 = Color3.fromRGB(0,255,100)
    floatingTPButton.TextColor3 = Color3.fromRGB(0,0,0)
    floatingTPButton.Text = "TP Roof"
    floatingTPButton.Parent = FloatingGui
    floatingTPButton.Active = true
    floatingTPButton.Draggable = true
    floatingTPButton.MouseButton1Click:Connect(teleportRoof)
end

TeleportTab:AddToggle({
    Title = "Teleport to Roof (Floating Button)",
    Description = "Show floating button for Teleport Roof",
    Value = false,
    Callback = function(state)
        if state then 
            createTPFloatingButton() 
        else
            if floatingTPButton then 
                floatingTPButton:Destroy() 
                floatingTPButton = nil 
            end
        end
    end
})

-- AFK Money
getgenv().AntiAFK = true
local afkActive = false
local afkPart
local afkLoop

local function toggleAFKMoney()
    afkActive = not afkActive

    if afkActive then
        afkPart = Instance.new("Part")
        afkPart.Size = Vector3.new(8, 1, 8)
        afkPart.Position = Vector3.new(0, 6000, 0)
        afkPart.Anchored = true
        afkPart.Transparency = 1
        afkPart.Parent = workspace

        afkLoop = game:GetService("RunService").Heartbeat:Connect(function()
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character.HumanoidRootPart.CFrame = afkPart.CFrame + Vector3.new(0, 4, 0)
            end
        end)

    else
        if afkLoop then
            afkLoop:Disconnect()
            afkLoop = nil
        end
        if afkPart then
            afkPart:Destroy()
            afkPart = nil
        end
    end
end

TeleportTab:AddButton({
    Title = "AFK Money (Legacy)",
    Description = "Stand in sky, prevent death/map fall",
    Callback = function()
        toggleAFKMoney()
    end
})

-- Teleport to Dead Player
local floatingDeadTPButton
local function teleportToDead()
    local char = player.Character
    if not char then return end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end
    local deadPlayer = nil
    for _,plr in pairs(Players:GetPlayers()) do
        local h = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid")
        if h and h.Health == 0 then
            deadPlayer = plr
            break
        end
    end
    if deadPlayer and deadPlayer.Character and deadPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local originalCFrame = root.CFrame
        root.CFrame = deadPlayer.Character.HumanoidRootPart.CFrame
        task.wait(1)
        root.CFrame = originalCFrame
    end
end

TeleportTab:AddButton({
    Title = "Teleport to Dead Player (Normal)",
    Description = "Warp to dead player for 1 second",
    Callback = teleportToDead
})

local function createDeadTPFloatingButton()
    if floatingDeadTPButton then return end
    floatingDeadTPButton = Instance.new("TextButton")
    floatingDeadTPButton.Size = UDim2.new(0,100,0,50)
    floatingDeadTPButton.Position = UDim2.new(0.5,-50,0.8,0)
    floatingDeadTPButton.AnchorPoint = Vector2.new(0.5,0)
    floatingDeadTPButton.BackgroundColor3 = Color3.fromRGB(0,255,255)
    floatingDeadTPButton.TextColor3 = Color3.fromRGB(0,0,0)
    floatingDeadTPButton.Text = "Dead TP"
    floatingDeadTPButton.Parent = FloatingGui
    floatingDeadTPButton.Active = true
    floatingDeadTPButton.Draggable = true
    floatingDeadTPButton.MouseButton1Click:Connect(teleportToDead)
end

TeleportTab:AddToggle({
    Title = "Teleport to Dead Player (Floating Button)",
    Description = "Show floating button for Dead TP",
    Value = false,
    Callback = function(state)
        if state then 
            createDeadTPFloatingButton() 
        else
            if floatingDeadTPButton then 
                floatingDeadTPButton:Destroy() 
                floatingDeadTPButton = nil 
            end
        end
    end
})

-- Wall Hack
local wallHackActive = false
local floatingWallButton
local wallPartsOriginalCollide = {}

local function setWallHack(state)
    wallHackActive = state
    if not wallHackActive then
        for part, collide in pairs(wallPartsOriginalCollide) do
            if part and part.Parent then
                part.CanCollide = collide
            end
        end
        wallPartsOriginalCollide = {}
    end
end

local function toggleWallHack()
    setWallHack(not wallHackActive)
    if floatingWallButton then
        floatingWallButton.Text = wallHackActive and "Wall Hack: ON" or "Wall Hack: OFF"
    end
end

task.spawn(function()
    while true do
        if wallHackActive then
            local char = player.Character
            if char then
                local root = char:FindFirstChild("HumanoidRootPart")
                if root then
                    local origin = root.Position
                    local forwardDir = root.CFrame.LookVector
                    for _, part in pairs(workspace:GetDescendants()) do
                        if part:IsA("BasePart") then
                            local toPart = part.Position - origin
                            local forwardDist = forwardDir:Dot(toPart)
                            local horizontalDist = (Vector3.new(toPart.X,0,toPart.Z)).Magnitude
                            local verticalDist = toPart.Y
                            if forwardDist > 0 and forwardDist < 5 and horizontalDist < 3 and verticalDist > -2 and verticalDist < 5 then
                                if wallPartsOriginalCollide[part] == nil then
                                    wallPartsOriginalCollide[part] = part.CanCollide
                                end
                                part.CanCollide = false
                            end
                        end
                    end
                end
            end
        end
        task.wait(0.05)
    end
end)

local function createWallFloatingButton()
    if floatingWallButton then return end
    floatingWallButton = Instance.new("TextButton")
    floatingWallButton.Size = UDim2.new(0,100,0,50)
    floatingWallButton.Position = UDim2.new(0.2,-50,0.6,0)
    floatingWallButton.AnchorPoint = Vector2.new(0.5,0)
    floatingWallButton.BackgroundColor3 = Color3.fromRGB(100,255,100)
    floatingWallButton.TextColor3 = Color3.fromRGB(0,0,0)
    floatingWallButton.Text = wallHackActive and "Wall Hack: ON" or "Wall Hack: OFF"
    floatingWallButton.Parent = FloatingGui
    floatingWallButton.Active = true
    floatingWallButton.Draggable = true
    floatingWallButton.MouseButton1Click:Connect(toggleWallHack)
end

ExtraTab:AddButton({
    Title = "Wall Hack (Normal)",
    Description = "Phase through front/side walls (real)",
    Callback = toggleWallHack
})

ExtraTab:AddToggle({
    Title = "Wall Hack (Floating Button)",
    Description = "Show floating button for Wall Hack",
    Value = false,
    Callback = function(state)
        if state then
            createWallFloatingButton()
        else
            if floatingWallButton then
                floatingWallButton:Destroy()
                floatingWallButton = nil
            end
            setWallHack(false)
        end
    end
})

-- Teleport to Player
local floatingTPPlayerButton
local function teleportToPlayer(targetPlayer)
    local char = player.Character
    if not char then return end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        root.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame
    end
end

local function createTPPlayerMenu()
    local menuGui = PlayerGui:FindFirstChild("TPPlayerMenu")
    if menuGui then menuGui:Destroy() end

    menuGui = Instance.new("ScreenGui")  
    menuGui.Name = "TPPlayerMenu"  
    menuGui.Parent = PlayerGui  
    menuGui.ResetOnSpawn = false  

    local frame = Instance.new("Frame")  
    frame.Size = UDim2.new(0,200,0,300)  
    frame.Position = UDim2.new(0.5,-100,0.3,0)  
    frame.BackgroundColor3 = Color3.fromRGB(50,50,50)  
    frame.Parent = menuGui  

    local layout = Instance.new("UIListLayout")  
    layout.Parent = frame  
    layout.SortOrder = Enum.SortOrder.LayoutOrder  
    layout.Padding = UDim.new(0,5)  

    for _, plr in pairs(Players:GetPlayers()) do  
        if plr ~= player then  
            local btn = Instance.new("TextButton")  
            btn.Size = UDim2.new(1,0,0,30)  
            btn.Text = plr.Name  
            btn.BackgroundColor3 = Color3.fromRGB(100,100,255)  
            btn.TextColor3 = Color3.fromRGB(255,255,255)  
            btn.Parent = frame  
            btn.MouseButton1Click:Connect(function()  
                teleportToPlayer(plr)  
                menuGui:Destroy()  
            end)  
        end  
    end
end

TeleportTab:AddButton({
    Title = "TeleTo Player (Normal)",
    Description = "Select player and teleport to them",
    Callback = createTPPlayerMenu
})

local function createFloatingTPPlayerButton()
    if floatingTPPlayerButton then return end
    floatingTPPlayerButton = Instance.new("TextButton")
    floatingTPPlayerButton.Size = UDim2.new(0,120,0,50)
    floatingTPPlayerButton.Position = UDim2.new(0.5,-60,0.75,0)
    floatingTPPlayerButton.AnchorPoint = Vector2.new(0.5,0)
    floatingTPPlayerButton.BackgroundColor3 = Color3.fromRGB(150,0,255)
    floatingTPPlayerButton.TextColor3 = Color3.fromRGB(255,255,255)
    floatingTPPlayerButton.Text = "TeleTo Player"
    floatingTPPlayerButton.Parent = FloatingGui
    floatingTPPlayerButton.Active = true
    floatingTPPlayerButton.Draggable = true
    floatingTPPlayerButton.MouseButton1Click:Connect(createTPPlayerMenu)
end

TeleportTab:AddToggle({
    Title = "TeleTo Player (Floating Button)",
    Description = "Show floating button for TeleTo Player",
    Value = false,
    Callback = function(state)
        if state then 
            createFloatingTPPlayerButton() 
        else
            if floatingTPPlayerButton then 
                floatingTPPlayerButton:Destroy() 
                floatingTPPlayerButton = nil 
            end
        end
    end
})

-- Moon Mode
local moonModeActive = false
local floatingMoonButton

local function toggleMoonMode()
    moonModeActive = not moonModeActive
    if floatingMoonButton then
        floatingMoonButton.Text = moonModeActive and "Moon Mode: ON" or "Moon Mode: OFF"
    end
end

task.spawn(function()
    while true do
        if moonModeActive then
            local char = player.Character
            if char then
                local root = char:FindFirstChild("HumanoidRootPart")
                local humanoid = char:FindFirstChildOfClass("Humanoid")
                if root and humanoid then
                    if humanoid.FloorMaterial == Enum.Material.Air and root.Velocity.Y < 0 then
                        root.Velocity = Vector3.new(root.Velocity.X, root.Velocity.Y * 0.3, root.Velocity.Z)
                    end
                end
            end
        end
        task.wait(0.05)
    end
end)

local function createMoonFloatingButton()
    if floatingMoonButton then return end
    floatingMoonButton = Instance.new("TextButton")
    floatingMoonButton.Size = UDim2.new(0,100,0,50)
    floatingMoonButton.Position = UDim2.new(0.8,-50,0.6,0)
    floatingMoonButton.AnchorPoint = Vector2.new(0.5,0)
    floatingMoonButton.BackgroundColor3 = Color3.fromRGB(100,100,255)
    floatingMoonButton.TextColor3 = Color3.fromRGB(255,255,255)
    floatingMoonButton.Text = moonModeActive and "Moon Mode: ON" or "Moon Mode: OFF"
    floatingMoonButton.Parent = FloatingGui
    floatingMoonButton.Active = true
    floatingMoonButton.Draggable = true
    floatingMoonButton.MouseButton1Click:Connect(toggleMoonMode)
end

ExtraTab:AddButton({
    Title = "Moon Mode (Normal)",
    Description = "Fall slowly from height without freezing",
    Callback = toggleMoonMode
})

ExtraTab:AddToggle({
    Title = "Moon Mode (Floating Button)",
    Description = "Show floating button for Moon Mode",
    Value = false,
    Callback = function(state)
        if state then 
            createMoonFloatingButton() 
        else
            if floatingMoonButton then 
                floatingMoonButton:Destroy() 
                floatingMoonButton = nil 
            end
            moonModeActive = false
        end
    end
})

-- Run External Script
ExtraTab:AddButton({
    Title = "Run External Script",
    Description = "Press to run script from Pastebin",
    Callback = function()
        local success, err = pcall(function()
            loadstring(game:HttpGet("https://pastebin.com/raw/GHDdPh2c"))()
        end)
        if not success then
            warn("Error running script: "..tostring(err))
        end
    end
})

-- Player ESP
local playerESPActive = false
local ESPBoxes = {}

local function createESPForPlayer(targetPlayer)
    if targetPlayer == player then return end
    local char = targetPlayer.Character
    if not char then return end

    local head = char:FindFirstChild("Head")
    local root = char:FindFirstChild("HumanoidRootPart")
    if not head or not root then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESPBillboard"
    billboard.Adornee = head
    billboard.Size = UDim2.new(0,200,0,50)
    billboard.StudsOffset = Vector3.new(0,2,0)
    billboard.AlwaysOnTop = true
    billboard.Parent = head

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1,0,1,0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255,255,255)
    label.TextStrokeTransparency = 0
    label.Font = Enum.Font.SourceSansBold
    label.TextScaled = true
    label.Text = targetPlayer.Name
    label.Parent = billboard

    local box = Instance.new("BoxHandleAdornment")
    box.Adornee = root
    box.Size = root.Size
    box.Color = BrickColor.new("White")
    box.AlwaysOnTop = true
    box.ZIndex = 5
    box.Parent = root

    ESPBoxes[targetPlayer] = {Billboard = billboard, Box = box}
end

local function removeESPForPlayer(targetPlayer)
    if ESPBoxes[targetPlayer] then
        if ESPBoxes[targetPlayer].Billboard then ESPBoxes[targetPlayer].Billboard:Destroy() end
        if ESPBoxes[targetPlayer].Box then ESPBoxes[targetPlayer].Box:Destroy() end
        ESPBoxes[targetPlayer] = nil
    end
end

local function togglePlayerESP(state)
    playerESPActive = state
    if state then
        for _, plr in pairs(Players:GetPlayers()) do
            createESPForPlayer(plr)
        end
    else
        for plr, _ in pairs(ESPBoxes) do
            removeESPForPlayer(plr)
        end
    end
end

Players.PlayerAdded:Connect(function(plr)
    if playerESPActive then
        plr.CharacterAdded:Connect(function()
            createESPForPlayer(plr)
        end)
    end
end)

Players.PlayerRemoving:Connect(function(plr)
    removeESPForPlayer(plr)
end)

VisualsTab:AddToggle({
    Title = "Player ESP",
    Description = "Show name above head and box around body",
    Value = false,
    Callback = togglePlayerESP
})

-- Smooth Dash
getgenv().dashEnabled = false
getgenv().dashSpeed = 50
local floatingDashButton
local dashVelocity = nil

local function startDash()
    if dashVelocity then return end
    local char = player.Character
    if not char then return end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end

    dashVelocity = Instance.new("BodyVelocity")
    dashVelocity.MaxForce = Vector3.new(400000, 0, 400000)
    dashVelocity.P = 1250
    dashVelocity.Parent = root

    task.spawn(function()
        while getgenv().dashEnabled and dashVelocity and dashVelocity.Parent do
            local cam = workspace.CurrentCamera
            if cam and root then
                local dir = cam.CFrame.LookVector
                dir = Vector3.new(dir.X, 0, dir.Z)
                if dir.Magnitude > 0 then dir = dir.Unit end
                dashVelocity.Velocity = dir * getgenv().dashSpeed
            end
            task.wait(0.03)
        end
        if dashVelocity then
            dashVelocity:Destroy()
            dashVelocity = nil
        end
    end)
end

SettingsTab:AddToggle({
    Title = "Smooth Dash (Normal)",
    Description = "Dash smoothly following view angle",
    Value = false,
    Callback = function(state)
        getgenv().dashEnabled = state
        if state then
            startDash()
        elseif dashVelocity then
            dashVelocity:Destroy()
            dashVelocity = nil
        end
    end
})

SettingsTab:AddTextBox({
    Title = "Dash Speed",
    Description = "Adjust dash speed",
    Placeholder = tostring(getgenv().dashSpeed),
    Callback = function(txt)
        local num = tonumber(txt)
        if num then getgenv().dashSpeed = num end
    end
})

local function createFloatingDashButton()
    if floatingDashButton then return end
    floatingDashButton = Instance.new("TextButton")
    floatingDashButton.Size = UDim2.new(0,120,0,50)
    floatingDashButton.Position = UDim2.new(0.5,-60,0.3,0)
    floatingDashButton.AnchorPoint = Vector2.new(0.5,0)
    floatingDashButton.BackgroundColor3 = Color3.fromRGB(0,170,255)
    floatingDashButton.TextColor3 = Color3.fromRGB(255,255,255)
    floatingDashButton.Text = getgenv().dashEnabled and "Dash: ON" or "Dash: OFF"
    floatingDashButton.Parent = FloatingGui
    floatingDashButton.Active = true
    floatingDashButton.Draggable = true

    floatingDashButton.MouseButton1Click:Connect(function()
        getgenv().dashEnabled = not getgenv().dashEnabled
        floatingDashButton.Text = getgenv().dashEnabled and "Dash: ON" or "Dash: OFF"
        if getgenv().dashEnabled then
            startDash()
        elseif dashVelocity then
            dashVelocity:Destroy()
            dashVelocity = nil
        end
    end)
end

SettingsTab:AddToggle({
    Title = "Smooth Dash (Floating Button)",
    Description = "Show floating button for Smooth Dash",
    Value = false,
    Callback = function(state)
        if state then
            createFloatingDashButton()
        else
            if floatingDashButton then
                floatingDashButton:Destroy()
                floatingDashButton = nil
            end
            getgenv().dashEnabled = false
            if dashVelocity then
                dashVelocity:Destroy()
                dashVelocity = nil
            end
        end
    end
})

-- Ticket ESP
EventTab:AddToggle({
    Title = "Ticket ESP",
    Description = "Show ticket locations on map",
    Value = false,
    Callback = function(state)
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local ticketESPThread

        local function getDistance(pos)
            local char = LocalPlayer.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            return hrp and (pos - hrp.Position).Magnitude or nil
        end

        local function createESP(part)
            local billboard = Instance.new("BillboardGui")
            billboard.Name = "TicketESP"
            billboard.Adornee = part
            billboard.Size = UDim2.new(0, 180, 0, 25)
            billboard.StudsOffset = Vector3.new(0, 3.2, 0)
            billboard.AlwaysOnTop = true
            billboard.LightInfluence = 0
            billboard.Parent = part

            local label = Instance.new("TextLabel")
            label.Name = "Ticket"
            label.Size = UDim2.new(1, 0, 1, 0)
            label.BackgroundTransparency = 1
            label.TextStrokeTransparency = 0.25
            label.TextScaled = true
            label.Font = Enum.Font.GothamSemibold
            label.TextColor3 = Color3.fromRGB(255, 255, 150)
            label.Text = "Ticket"
            label.Parent = billboard

            return billboard
        end

        local function removeAllTicketESP()
            local ticketFolder = workspace:FindFirstChild("Game") 
                and workspace.Game:FindFirstChild("Effects") 
                and workspace.Game.Effects:FindFirstChild("Tickets")
            if ticketFolder then
                for _, ticketModel in ipairs(ticketFolder:GetChildren()) do
                    if ticketModel:IsA("Model") then
                        local part = ticketModel:FindFirstChildWhichIsA("BasePart")
                        if part then
                            local existing = part:FindFirstChild("TicketESP")
                            if existing then existing:Destroy() end
                        end
                    end
                end
            end
        end

        if state then
            ticketESPThread = task.spawn(function()
                while state do
                    local ticketFolder = workspace:FindFirstChild("Game") 
                        and workspace.Game:FindFirstChild("Effects") 
                        and workspace.Game.Effects:FindFirstChild("Tickets")
                    if ticketFolder then
                        for _, ticketModel in ipairs(ticketFolder:GetChildren()) do
                            if ticketModel:IsA("Model") then
                                local part = ticketModel:FindFirstChildWhichIsA("BasePart")
                                if part then
                                    local billboard = part:FindFirstChild("TicketESP") or createESP(part)
                                    local label = billboard and billboard:FindFirstChild("Ticket")
                                    if label then
                                        local dist = getDistance(part.Position)
                                        if dist then
                                            label.Text = string.format("%s\n%.0f studs", ticketModel.Name, dist)
                                        else
                                            label.Text = ticketModel.Name
                                        end
                                    end
                                end
                            end
                        end
                    end
                    task.wait(0.5)
                end
            end)
        else
            removeAllTicketESP()
        end
    end
})

-- Nextbot ESP
VisualsTab:AddButton({
    Title = "Nextbot ESP",
    Description = "Toggle Nextbot ESP",
    Callback = function()
        local LocalPlayer = game:GetService("Players").LocalPlayer

        if _G.NextbotESPEnabled then
            _G.NextbotESPEnabled = false
            if _G.NextbotESPThread and coroutine.status(_G.NextbotESPThread) ~= "dead" then
                coroutine.close(_G.NextbotESPThread)
                _G.NextbotESPThread = nil
            end

            local folder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
            if folder then
                for _, npc in ipairs(folder:GetChildren()) do
                    local part = (npc:IsA("Model") and (npc:FindFirstChild("Root") or npc:FindFirstChild("Head") or npc:FindFirstChild("HumanoidRootPart") or npc:FindFirstChildWhichIsA("BasePart"))) or nil
                    if part then
                        local esp = part:FindFirstChild("NextbotESP")
                        if esp then esp:Destroy() end
                    end
                end
            end

            print("ðŸ›‘ Nextbot ESP Disabled")
        else
            _G.NextbotESPEnabled = true

            _G.NextbotESPThread = coroutine.create(function()
                while _G.NextbotESPEnabled do
                    local folder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
                    if folder then
                        for _, npc in ipairs(folder:GetChildren()) do
                            if npc:GetAttribute("Team") == "Nextbot" then
                                local part = (npc:IsA("Model") and (npc:FindFirstChild("Root") or npc:FindFirstChild("Head") or npc:FindFirstChild("HumanoidRootPart") or npc:FindFirstChildWhichIsA("BasePart"))) or nil
                                if part then
                                    local billboard = part:FindFirstChild("NextbotESP")
                                    if not billboard then
                                        billboard = Instance.new("BillboardGui")
                                        billboard.Name = "NextbotESP"
                                        billboard.Adornee = part
                                        billboard.Size = UDim2.new(0, 180, 0, 25)
                                        billboard.StudsOffset = Vector3.new(0, 3.2, 0)
                                        billboard.AlwaysOnTop = true
                                        billboard.LightInfluence = 0
                                        billboard.Parent = part

                                        local label = Instance.new("TextLabel")
                                        label.Name = "Label"
                                        label.Size = UDim2.new(1, 0, 1, 0)
                                        label.BackgroundTransparency = 1
                                        label.TextStrokeTransparency = 0.25
                                        label.TextScaled = true
                                        label.Font = Enum.Font.GothamSemibold
                                        label.TextColor3 = Color3.fromRGB(255, 255, 255)
                                        label.Parent = billboard
                                    end

                                    local label = billboard:FindFirstChild("Label")
                                    if label then
                                        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                                        local dist = hrp and (part.Position - hrp.Position).Magnitude or nil
                                        if dist then
                                            label.Text = string.format("%s\n%.0f studs", npc.Name, dist)
                                            if dist <= 12 then
                                                label.TextColor3 = Color3.fromRGB(50, 50, 50)
                                            elseif dist <= 60 then
                                                local t = (dist - 6) / 14
                                                label.TextColor3 = Color3.fromRGB(255, 120 + (255 - 120) * t, 120)
                                            else
                                                label.TextColor3 = Color3.fromRGB(200, 150, 255)
                                            end
                                        else
                                            label.Text = npc.Name
                                            label.TextColor3 = Color3.fromRGB(255, 255, 255)
                                        end
                                    end
                                end
                            end
                        end
                    end
                    task.wait(0.5)
                end
            end)
            coroutine.resume(_G.NextbotESPThread)
            print("âœ… Nextbot ESP Enabled")
        end
    end
})

-- FPS Display
FPSTab:AddButton({
    Title = "Show FPS",
    Description = "Toggle FPS display",
    Callback = function()
        local player = game.Players.LocalPlayer
        local playerGui = player:WaitForChild("PlayerGui")

        local existingGui = playerGui:FindFirstChild("FPSGui")
        if existingGui then
            existingGui:Destroy()
            return
        end

        local fpsGui = Instance.new("ScreenGui")
        fpsGui.Name = "FPSGui"
        fpsGui.ResetOnSpawn = false
        fpsGui.Parent = playerGui

        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(0, 200, 0, 100)
        frame.Position = UDim2.new(1, -210, 0, 10)
        frame.BackgroundTransparency = 0.5
        frame.BackgroundColor3 = Color3.fromRGB(0,0,0)
        frame.Parent = fpsGui

        local fpsLabel = Instance.new("TextLabel")
        fpsLabel.Size = UDim2.new(1, -10, 0, 30)
        fpsLabel.Position = UDim2.new(0, 5, 0, 5)
        fpsLabel.BackgroundTransparency = 1
        fpsLabel.TextColor3 = Color3.fromRGB(255,255,255)
        fpsLabel.TextScaled = true
        fpsLabel.Font = Enum.Font.GothamSemibold
        fpsLabel.Text = "FPS: 0"
        fpsLabel.Parent = frame

        local othersLabel = Instance.new("TextLabel")
        othersLabel.Size = UDim2.new(1, -10, 1, -40)
        othersLabel.Position = UDim2.new(0, 5, 0, 35)
        othersLabel.BackgroundTransparency = 1
        othersLabel.TextColor3 = Color3.fromRGB(180,180,255)
        othersLabel.TextScaled = true
        othersLabel.Font = Enum.Font.GothamSemibold
        othersLabel.Text = "Players FPS:"
        othersLabel.TextWrapped = true
        othersLabel.TextYAlignment = Enum.TextYAlignment.Top
        othersLabel.Parent = frame

        local lastTime = tick()
        local frameCount = 0
        local runService = game:GetService("RunService")

        runService.RenderStepped:Connect(function()
            frameCount += 1
            local now = tick()
            if now - lastTime >= 1 then
                fpsLabel.Text = "FPS: " .. frameCount
                frameCount = 0
                lastTime = now

                local players = game.Players:GetPlayers()
                local otherText = "Players FPS:\n"
                for _, p in pairs(players) do
                    if p ~= player then
                        otherText = otherText .. p.Name .. ": ?\n"
                    end
                end
                othersLabel.Text = otherText
            end
        end)
    end
})

-- Click Teleport
local teleportEnabled = false
local floatingTeleportButton
local teleportConnection

local function startTeleport()
    local UIS = game:GetService("UserInputService")
    local player = game.Players.LocalPlayer
    local mouse = player:GetMouse()

    local function onClick()
        if teleportEnabled then
            local targetPos = mouse.Hit.Position + Vector3.new(0, 3, 0)
            local char = player.Character
            if char then
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.CFrame = CFrame.new(targetPos)
                end
            end
        end
    end

    local clickConnection = mouse.Button1Down:Connect(onClick)
    
    return clickConnection
end

TeleportTab:AddToggle({
    Title = "Click Teleport",
    Description = "Toggle Click Teleport Mode",
    Value = false,
    Callback = function(state)
        teleportEnabled = state
        if state then
            teleportConnection = startTeleport()
        elseif teleportConnection then
            teleportConnection:Disconnect()
            teleportConnection = nil
        end
    end
})

local function createFloatingTeleportButton()
    if floatingTeleportButton then return end

    floatingTeleportButton = Instance.new("TextButton")
    floatingTeleportButton.Size = UDim2.new(0, 140, 0, 50)
    floatingTeleportButton.Position = UDim2.new(0.5, -70, 0.4, 0)
    floatingTeleportButton.AnchorPoint = Vector2.new(0.5, 0)
    floatingTeleportButton.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
    floatingTeleportButton.TextColor3 = Color3.fromRGB(255,255,255)
    floatingTeleportButton.Text = teleportEnabled and "Teleport: ON" or "Teleport: OFF"
    floatingTeleportButton.Parent = FloatingGui
    floatingTeleportButton.Active = true
    floatingTeleportButton.Draggable = true

    floatingTeleportButton.MouseButton1Click:Connect(function()
        teleportEnabled = not teleportEnabled
        floatingTeleportButton.Text = teleportEnabled and "Teleport: ON" or "Teleport: OFF"
        if teleportEnabled then
            teleportConnection = startTeleport()
        elseif teleportConnection then
            teleportConnection:Disconnect()
            teleportConnection = nil
        end
    end)
end

TeleportTab:AddToggle({
    Title = "Click Teleport (Floating Button)",
    Description = "Show floating button for Teleport",
    Value = false,
    Callback = function(state)
        if state then
            createFloatingTeleportButton()
        else
            if floatingTeleportButton then
                floatingTeleportButton:Destroy()
                floatingTeleportButton = nil
            end
            teleportEnabled = false
            if teleportConnection then
                teleportConnection:Disconnect()
                teleportConnection = nil
            end
        end
    end
})

-- Reduce Graphics
FPSTab:AddButton({
    Title = "Reduce Graphics V.1",
    Description = "All parts smooth",
    Callback = function()
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") then
                obj.Material = Enum.Material.SmoothPlastic
                obj.Reflectance = 0
            elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
                obj.Enabled = false
            end
        end
        print("âœ… Graphics Reduced V.1")
    end
})

FPSTab:AddButton({
    Title = "Reduce Graphics V.2",
    Description = "Smooth + remove fog and effects",
    Callback = function()
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") then
                obj.Material = Enum.Material.SmoothPlastic
                obj.Reflectance = 0
            elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
                obj.Enabled = false
            elseif obj:IsA("Decal") or obj:IsA("Texture") then
                obj:Destroy()
            end
        end

        local Lighting = game:GetService("Lighting")
        Lighting.FogEnd = 100000
        Lighting.FogStart = 0
        Lighting.GlobalShadows = false
        print("âœ… Graphics Reduced V.2")
    end
})

FPSTab:AddButton({
    Title = "Increase Brightness",
    Description = "Slightly brighten screen",
    Callback = function()
        local Lighting = game:GetService("Lighting")
        Lighting.Brightness = (Lighting.Brightness or 2) + 1
        print("âœ… Brightness Increased")
    end
})

-- Auto Ticket Farm
EventTab:AddToggle({
    Title = "Auto Ticket Farm",
    Description = "Collect tickets automatically",
    Value = false,
    Callback = function(state)
        getgenv().AutoTicketFarm = state
        if state then
            task.spawn(function()
                while getgenv().AutoTicketFarm do
                    task.wait(0.1)
                    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local hrp = player.Character.HumanoidRootPart
                        local ticketsFolder = workspace:FindFirstChild("Game")
                        and workspace.Game:FindFirstChild("Effects")
                        and workspace.Game.Effects:FindFirstChild("Tickets")
                        if ticketsFolder then
                            for _, ticket in pairs(ticketsFolder:GetChildren()) do
                                if not getgenv().AutoTicketFarm then break end
                                local root = ticket:FindFirstChild("HumanoidRootPart")
                                if root then
                                    local pos = root.Position
                                    local downPos = CFrame.new(pos.X, pos.Y - 15, pos.Z)
                                    local upPos = CFrame.new(pos.X, pos.Y + 2, pos.Z)

                                    hrp.CFrame = downPos
                                    task.wait(0.15)
                                    hrp.CFrame = upPos
                                    task.wait(0.05)

                                    local success = false    
                                    if game:GetService("ReplicatedStorage"):FindFirstChild("Events")     
                                       and game.ReplicatedStorage.Events:FindFirstChild("CollectTicket") then    
                                        local ok, _ = pcall(function()    
                                            game.ReplicatedStorage.Events.CollectTicket:FireServer(ticket)    
                                        end)    
                                        success = ok    
                                    end    

                                    local startTime = tick()    
                                    repeat task.wait(0.05) until not ticket.Parent or tick() - startTime > 2    
                                    if not ticket.Parent or success then    
                                        hrp.CFrame = CFrame.new(pos.X, 1300, pos.Z)    
                                        task.wait(0.3)    
                                    end    
                                end    
                            end    
                        end    
                    end    
                end    
            end)    
        end
    end
})

-- Auto Carry
getgenv().autoCarryEnabled = false
getgenv().autoCarryConnection = nil

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

local function startAutoCarry()
    if getgenv().autoCarryConnection then return end

    getgenv().autoCarryConnection = RunService.Heartbeat:Connect(function()
        if not getgenv().autoCarryEnabled then return end

        local char = localPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local otherHRP = plr.Character.HumanoidRootPart
                local dist = (hrp.Position - otherHRP.Position).Magnitude

                if dist <= 20 then
                    pcall(function()
                        ReplicatedStorage.Events.Character.Interact:FireServer("Carry", nil, plr.Name)
                    end)
                    task.wait(0.05)
                end
            end
        end
    end)
end

local function stopAutoCarry()
    if getgenv().autoCarryConnection then
        getgenv().autoCarryConnection:Disconnect()
        getgenv().autoCarryConnection = nil
    end
end

MainTab:AddToggle({
    Title = "Auto Carry",
    Description = "Toggle auto carry players",
    Value = false,
    Callback = function(state)
        getgenv().autoCarryEnabled = state

        if state then 
            startAutoCarry()
        else
            stopAutoCarry()
        end

        if getgenv().floatingCarryButton then
            getgenv().floatingCarryButton.Text = state and "Auto Carry: ON" or "Auto Carry: OFF"
            getgenv().floatingCarryButton.BackgroundColor3 =
                state and Color3.fromRGB(0,200,0) or Color3.fromRGB(200,0,0)
        end
    end
})

local function createCarryFloatingButton()
    if getgenv().floatingCarryButton then
        getgenv().floatingCarryButton:Destroy()
        getgenv().floatingCarryButton = nil
        return
    end

    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0,150,0,50)
    btn.Position = UDim2.new(0.25,0,0.3,0)
    btn.BackgroundColor3 = getgenv().autoCarryEnabled and Color3.fromRGB(0,200,0) or Color3.fromRGB(200,0,0)
    btn.TextColor3 = Color3.new(1,1,1)
    btn.TextScaled = true
    btn.Text = getgenv().autoCarryEnabled and "Auto Carry: ON" or "Auto Carry: OFF"
    btn.Parent = FloatingGui
    btn.Active = true
    btn.Draggable = true

    Instance.new("UICorner", btn).CornerRadius = UDim.new(0,12)
    local stroke = Instance.new("UIStroke", btn)
    stroke.Thickness = 3
    stroke.Color = Color3.new(1,1,1)

    getgenv().floatingCarryButton = btn

    btn.MouseButton1Click:Connect(function()
        getgenv().autoCarryEnabled = not getgenv().autoCarryEnabled

        if getgenv().autoCarryEnabled then
            startAutoCarry()
        else
            stopAutoCarry()
        end

        btn.Text = getgenv().autoCarryEnabled and "Auto Carry: ON" or "Auto Carry: OFF"
        btn.BackgroundColor3 =
            getgenv().autoCarryEnabled and Color3.fromRGB(0,200,0) or Color3.fromRGB(200,0,0)
    end)
end

MainTab:AddButton({
    Title = "Pull Auto Carry Button",
    Description = "Create/remove floating carry button",
    Callback = createCarryFloatingButton
})

-- Infinite Slide
local infiniteSlideEnabled = false
local slideFrictionValue = -8
local cachedTables
local plrModel
local slideConnection
local floatingSlideButton

local keys = {
    "Friction","AirStrafeAcceleration","JumpHeight","RunDeaccel",
    "JumpSpeedMultiplier","JumpCap","SprintCap","WalkSpeedMultiplier",
    "BhopEnabled","Speed","AirAcceleration","RunAccel","SprintAcceleration"
}

local function hasAll(tbl)
    if type(tbl) ~= "table" then return false end
    for _, k in ipairs(keys) do if rawget(tbl, k) == nil then return false end end
    return true
end

local function setFriction(value)
    if not cachedTables then return end
    for _, t in ipairs(cachedTables) do
        pcall(function() t.Friction = value end)
    end
end

local function updatePlayerModel()
    local GameFolder = workspace:FindFirstChild("Game")
    local PlayersFolder = GameFolder and GameFolder:FindFirstChild("Players")
    if PlayersFolder then
        plrModel = PlayersFolder:FindFirstChild(player.Name)
    else
        plrModel = nil
    end
end

local function onHeartbeat()
    if not plrModel then setFriction(5); return end
    local success, currentState = pcall(function() return plrModel:GetAttribute("State") end)
    if success and currentState then
        if currentState == "Slide" then
            pcall(function() plrModel:SetAttribute("State", "EmotingSlide") end)
        elseif currentState == "EmotingSlide" then
            setFriction(slideFrictionValue)
        else
            setFriction(5)
        end
    else
        setFriction(5)
    end
end

local function toggleInfiniteSlide()
    infiniteSlideEnabled = not infiniteSlideEnabled

    if slideConnection then slideConnection:Disconnect(); slideConnection = nil end

    if infiniteSlideEnabled then
        cachedTables = {}
        for _, obj in ipairs(getgc(true)) do
            local success, result = pcall(function() if hasAll(obj) then return obj end end)
            if success and result then table.insert(cachedTables, result) end
        end
        updatePlayerModel()
        slideConnection = RunService.Heartbeat:Connect(onHeartbeat)
        player.CharacterAdded:Connect(function() task.wait(0.1); updatePlayerModel() end)
    else
        cachedTables = nil
        plrModel = nil
        setFriction(5)
    end

    if floatingSlideButton then
        floatingSlideButton.BackgroundColor3 = infiniteSlideEnabled and Color3.fromRGB(0,200,0) or Color3.fromRGB(200,0,0)
        floatingSlideButton.Text = infiniteSlideEnabled and "Infinite Slide: ON" or "Infinite Slide: OFF"
    end
end

MainTab:AddToggle({
    Title = "Infinite Slide",
    Description = "Toggle Infinite Slide",
    Value = false,
    Callback = function(state)
        infiniteSlideEnabled = state
        toggleInfiniteSlide()
    end
})

SettingsTab:AddSlider({
    Title = "Slide Friction",
    Description = "Adjust slide force (lower = faster)",
    Min = -500,
    Max = -1,
    Value = slideFrictionValue,
    Callback = function(val)
        slideFrictionValue = val
    end
})

local function createSlideFloatingButton()
    if floatingSlideButton then return end
    floatingSlideButton = Instance.new("TextButton")
    floatingSlideButton.Size = UDim2.new(0,150,0,50)
    floatingSlideButton.Position = UDim2.new(0.8,0,0.3,0)
    floatingSlideButton.AnchorPoint = Vector2.new(0.5,0.5)
    floatingSlideButton.BackgroundColor3 = infiniteSlideEnabled and Color3.fromRGB(0,200,0) or Color3.fromRGB(200,0,0)
    floatingSlideButton.TextColor3 = Color3.fromRGB(255,255,255)
    floatingSlideButton.Text = infiniteSlideEnabled and "Infinite Slide: ON" or "Infinite Slide: OFF"
    floatingSlideButton.TextScaled = true
    floatingSlideButton.Parent = FloatingGui
    floatingSlideButton.Active = true
    floatingSlideButton.Draggable = true
    Instance.new("UICorner", floatingSlideButton).CornerRadius = UDim.new(0,12)
    local border = Instance.new("UIStroke", floatingSlideButton)
    border.Thickness = 3
    border.Color = Color3.fromRGB(255,255,255)

    floatingSlideButton.MouseButton1Click:Connect(toggleInfiniteSlide)
end

MainTab:AddButton({
    Title = "Pull Infinite Slide Button",
    Description = "Create floating button for Infinite Slide",
    Callback = createSlideFloatingButton
})

-- Speed, Jump, Strafe Settings
local currentSettings = {
    Speed = 1500,
    JumpCap = 1,
    AirStrafeAcceleration = 187
}

local requiredFields = {
    Friction=true, AirStrafeAcceleration=true, JumpHeight=true, RunDeaccel=true,
    JumpSpeedMultiplier=true, JumpCap=true, SprintCap=true, WalkSpeedMultiplier=true,
    BhopEnabled=true, Speed=true, AirAcceleration=true, RunAccel=true, SprintAcceleration=true
}

local function getMatchingTables()
    local matched = {}
    for _, obj in pairs(getgc(true)) do
        if typeof(obj) == "table" then
            local ok = true
            for field in pairs(requiredFields) do
                if rawget(obj, field) == nil then ok = false break end
            end
            if ok then
                table.insert(matched, obj)
            end
        end
    end
    return matched
end

local function applyToTables()
    for _, tbl in ipairs(getMatchingTables()) do
        pcall(function()
            tbl.Speed = currentSettings.Speed
            tbl.JumpCap = currentSettings.JumpCap
            tbl.AirStrafeAcceleration = currentSettings.AirStrafeAcceleration
        end)
    end
end

SettingsTab:AddSlider({
    Title = "Speed",
    Min = 1450,
    Max = 1000000,
    Default = currentSettings.Speed,
    Callback = function(val)
        currentSettings.Speed = val
        applyToTables()
    end
})

SettingsTab:AddSlider({
    Title = "Jump Cap",
    Min = 0.1,
    Max = 5000,
    Default = currentSettings.JumpCap,
    Callback = function(val)
        currentSettings.JumpCap = val
        applyToTables()
    end
})

SettingsTab:AddSlider({
    Title = "Strafe Acceleration",
    Min = 200,
    Max = 1000000,
    Default = currentSettings.AirStrafeAcceleration,
    Callback = function(val)
        currentSettings.AirStrafeAcceleration = val
        applyToTables()
    end
})

getgenv().ApplyMode = "Not Optimized"
SettingsTab:AddDropdown({
    Title = "Apply Method",
    Options = {"Not Optimized", "Optimized"},
    Default = {getgenv().ApplyMode},
    MultipleOptions = false,
    Callback = function(option)
        getgenv().ApplyMode = option[1]
    end
})

player.CharacterAdded:Connect(function()
    task.wait(1)
    applyToTables()
end)

-- Downed Player ESP
local downedESPEnabled = false
local downedBillboards = {}

local function updateDownedESP()
    for plr, billboard in pairs(downedBillboards) do
        if billboard then billboard:Destroy() end
    end
    downedBillboards = {}

    if not downedESPEnabled then return end

    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= player and plr.Character then
            local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
            local root = plr.Character:FindFirstChild("HumanoidRootPart")
            if humanoid and root and humanoid.Health <= 0 then
                local billboard = Instance.new("BillboardGui")
                billboard.Name = "DownedESP"
                billboard.Adornee = root
                billboard.Size = UDim2.new(0, 150, 0, 50)
                billboard.StudsOffset = Vector3.new(0,3,0)
                billboard.AlwaysOnTop = true
                billboard.Parent = root

                local textLabel = Instance.new("TextLabel")
                textLabel.Size = UDim2.new(1,0,1,0)
                textLabel.BackgroundTransparency = 1
                textLabel.Text = "Downed"
                textLabel.TextColor3 = Color3.fromRGB(255,0,0)
                textLabel.TextScaled = true
                textLabel.Font = Enum.Font.GothamBlack
                textLabel.Parent = billboard

                downedBillboards[plr] = billboard
            end
        end
    end
end

task.spawn(function()
    while true do
        if downedESPEnabled then
            updateDownedESP()
        else
            for plr, billboard in pairs(downedBillboards) do
                if billboard then billboard:Destroy() end
            end
            downedBillboards = {}
        end
        task.wait(0.5)
    end
end)

VisualsTab:AddToggle({
    Title = "Downed Player ESP",
    Description = "Show 'Downed' red text above players with 0 health",
    Value = false,
    Callback = function(state)
        downedESPEnabled = state
    end
})

-- Collect All Tickets
EventTab:AddButton({
    Title = "Collect All Tickets",
    Description = "Teleport to collect tickets one by one",
    Callback = function()
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local character = LocalPlayer.Character
        if not character then return end
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local ticketFolder = workspace:FindFirstChild("Game")
            and workspace.Game:FindFirstChild("Effects")
            and workspace.Game.Effects:FindFirstChild("Tickets")
        if not ticketFolder then return end

        task.spawn(function()
            while true do
                local tickets = {}
                for _, ticketModel in ipairs(ticketFolder:GetChildren()) do
                    if ticketModel:IsA("Model") then
                        local part = ticketModel:FindFirstChildWhichIsA("BasePart")
                        if part then
                            table.insert(tickets, part)
                        end
                    end
                end

                if #tickets == 0 then
                    break
                end

                for _, part in ipairs(tickets) do
                    if hrp and part then
                        hrp.CFrame = CFrame.new(part.Position + Vector3.new(0,3,0))
                        task.wait(1)
                    end
                end
            end
        end)
    end
})

-- Movement Recording
local recording = false
local playing = false
local recordedFrames = {}
local recordStartTime = 0
local displayTimeLabel

local TweenService = game:GetService("TweenService")
local PlayerGui = player:WaitForChild("PlayerGui")

local function updateTimeLabel()
    if not displayTimeLabel then
        displayTimeLabel = Instance.new("TextLabel")
        displayTimeLabel.Size = UDim2.new(0,150,0,50)
        displayTimeLabel.Position = UDim2.new(0.5,-75,0,50)
        displayTimeLabel.BackgroundTransparency = 0.5
        displayTimeLabel.BackgroundColor3 = Color3.fromRGB(0,0,0)
        displayTimeLabel.TextColor3 = Color3.fromRGB(255,255,255)
        displayTimeLabel.TextScaled = true
        displayTimeLabel.Parent = PlayerGui
    end
end

ExtraTab:AddButton({
    Title = "Start Recording Movement",
    Description = "Press to start/stop recording movement",
    Callback = function()
        local char = player.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        recording = not recording
        if recording then
            recordedFrames = {}
            recordStartTime = tick()
            updateTimeLabel()
            displayTimeLabel.Text = "0.0s"
            
            task.spawn(function()
                while recording do
                    local time = tick() - recordStartTime
                    displayTimeLabel.Text = string.format("%.1fs", time)
                    table.insert(recordedFrames, hrp.CFrame)
                    task.wait(0.1)
                end
                if displayTimeLabel then displayTimeLabel:Destroy(); displayTimeLabel = nil end
            end)
        end
    end
})

ExtraTab:AddButton({
    Title = "Playback Movement (Smooth)",
    Description = "Press to start/stop playing recorded movement",
    Callback = function()
        local char = player.Character
        if not char or #recordedFrames == 0 then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        playing = not playing
        task.spawn(function()
            while playing do
                for i = 1, #recordedFrames-1 do
                    if not playing then break end
                    local startCFrame = recordedFrames[i]
                    local endCFrame = recordedFrames[i+1]
                    local tween = TweenService:Create(hrp, TweenInfo.new(0.1, Enum.EasingStyle.Linear), {CFrame=endCFrame})
                    tween:Play()
                    tween.Completed:Wait()
                end
            end
        end)
    end
})

ExtraTab:AddButton({
    Title = "Reset Movement",
    Description = "Clear all recorded data",
    Callback = function()
        recordedFrames = {}
        recording = false
        playing = false
        if displayTimeLabel then displayTimeLabel:Destroy(); displayTimeLabel = nil end
    end
})

-- Delete Barrier
local workspace = game:GetService("Workspace")
local hiddenParts = {}
local deleteToggle = false

local function findParts()
    local found = {}
    local function scan(parent)
        for _, obj in ipairs(parent:GetChildren()) do
            if obj:IsA("BasePart") and (obj.Name == "Barrier" or obj.Name == "MapBarrier") then
                table.insert(found, obj)
            end
            scan(obj)
        end
    end
    scan(workspace)
    return found
end

local function deleteAll()
    for _, part in ipairs(findParts()) do
        if part and part.Parent then
            hiddenParts[part] = {
                Parent = part.Parent,
                CFrame = part.CFrame,
                Transparency = part.Transparency,
                CanCollide = part.CanCollide
            }
            part.Parent = nil
        end
    end
end

local function restoreAll()
    for part, data in pairs(hiddenParts) do
        if part then
            part.Parent = data.Parent
            part.CFrame = data.CFrame
            part.Transparency = data.Transparency
            part.CanCollide = data.CanCollide
        end
    end
    hiddenParts = {}
end

ExtraTab:AddToggle({
    Title = "Delete/Restore Barrier & MapBarrier",
    Description = "Toggle delete or restore all parts",
    Value = false,
    Callback = function(state)
        deleteToggle = state
        if deleteToggle then
            deleteAll()
        else
            restoreAll()
        end
    end
})

-- Auto Collect Turkey
local autoTurkey = false
local autoTurkeyThread

EventTab:AddToggle({
    Title = "Auto Collect Turkey",
    Description = "Teleport to Nextbot named Turkey automatically",
    Value = false,
    Callback = function(state)
        autoTurkey = state

        if autoTurkey then
            autoTurkeyThread = coroutine.create(function()
                local player = game.Players.LocalPlayer
                while autoTurkey do
                    local char = player.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        local hrp = char.HumanoidRootPart
                        local turkeyNPC
                        local folder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
                        if folder then
                            for _, npc in ipairs(folder:GetChildren()) do
                                if npc.Name == "Turkey" then
                                    turkeyNPC = npc
                                    break
                                end
                            end
                        end

                        if turkeyNPC and turkeyNPC.Parent then
                            local targetPart = turkeyNPC:FindFirstChild("Root") or turkeyNPC:FindFirstChild("HumanoidRootPart") or turkeyNPC:FindFirstChild("Head")
                            if targetPart then
                                hrp.CFrame = targetPart.CFrame + Vector3.new(0, 3, 0)
                            end
                        else
                            hrp.CFrame = CFrame.new(hrp.Position.X, 1300, hrp.Position.Z)
                        end
                    end
                    task.wait(0.5)
                end
            end)
            coroutine.resume(autoTurkeyThread)
        else
            autoTurkey = false
            if autoTurkeyThread and coroutine.status(autoTurkeyThread) ~= "dead" then
                coroutine.close(autoTurkeyThread)
                autoTurkeyThread = nil
            end
        end
    end
})

-- Warp Escape Bot
local warpBotActive = false
local warpBotCoroutine

ExtraTab:AddToggle({
    Title = "Warp Escape Bot",
    Description = "When nextbot close, warp to highest player",
    Value = false,
    Callback = function(state)
        warpBotActive = state

        if warpBotActive then
            warpBotCoroutine = coroutine.create(function()
                local RunService = game:GetService("RunService")
                local LocalPlayer = game:GetService("Players").LocalPlayer
                local Players = game:GetService("Players")
                while warpBotActive do
                    task.wait(0.1)
                    local char = LocalPlayer.Character
                    if not char then continue end
                    local root = char:FindFirstChild("HumanoidRootPart")
                    if not root then continue end

                    local folder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
                    if folder then
                        for _, npc in ipairs(folder:GetChildren()) do
                            if npc:GetAttribute("Team") == "Nextbot" then
                                local npcPart = npc:FindFirstChild("Root") or npc:FindFirstChild("HumanoidRootPart")
                                if npcPart and (npcPart.Position - root.Position).Magnitude <= 10 then
                                    local targetPlayer = nil
                                    local maxY = -math.huge
                                    for _, plr in ipairs(Players:GetPlayers()) do
                                        if plr ~= LocalPlayer and plr.Character then
                                            local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
                                            if hrp then
                                                if hrp.Position.Y > maxY then
                                                    maxY = hrp.Position.Y
                                                    targetPlayer = hrp
                                                end
                                            end
                                        end
                                    end
                                    if targetPlayer then
                                        root.CFrame = targetPlayer.CFrame + Vector3.new(0,2,0)
                                    end
                                end
                            end
                        end
                    end
                end
            end)
            coroutine.resume(warpBotCoroutine)
        else
            if warpBotCoroutine and coroutine.status(warpBotCoroutine) ~= "dead" then
                coroutine.close(warpBotCoroutine)
            end
            warpBotCoroutine = nil
        end
    end
})

-- Change Time
ExtraTab:AddButton({
    Title = "Change to Day",
    Description = "Set map time to 12:00",
    Callback = function()
        local Lighting = game:GetService("Lighting")
        Lighting.ClockTime = 12
        print("Set time to day 12:00")
    end
})

ExtraTab:AddButton({
    Title = "Change to Night",
    Description = "Set map time to 22:00",
    Callback = function()
        local Lighting = game:GetService("Lighting")
        Lighting.ClockTime = 22
        print("Set time to night 22:00")
    end
})

-- Collect Downed Players
local AutoCarryEnabled = false
local CarryConnection

TeleportTab:AddToggle({
    Title = "Collect Downed Players",
    Description = "Teleport to downed players and carry",
    Value = false,
    Callback = function(state)
        AutoCarryEnabled = state

        if CarryConnection then
            CarryConnection:Disconnect()
            CarryConnection = nil
        end

        if state then
            CarryConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if not AutoCarryEnabled then return end
                local localChar = game.Players.LocalPlayer.Character
                local hrp = localChar and localChar:FindFirstChild("HumanoidRootPart")
                if not hrp then return end

                local originalCFrame = hrp.CFrame

                local fallenPlayers = {}
                for _, plr in ipairs(game.Players:GetPlayers()) do
                    if plr ~= game.Players.LocalPlayer and plr.Character then
                        local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
                        if humanoid and humanoid.Health <= 0 then
                            table.insert(fallenPlayers, plr)
                        end
                    end
                end

                if #fallenPlayers > 0 then
                    local target = fallenPlayers[math.random(1, #fallenPlayers)]
                    local targetHRP = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
                    if targetHRP then
                        hrp.CFrame = targetHRP.CFrame + Vector3.new(0,3,0)

                        pcall(function()
                            game:GetService("ReplicatedStorage"):WaitForChild("Events")
                                :WaitForChild("Character")
                                :WaitForChild("Interact")
                                :FireServer("Carry", nil, target.Name)
                        end)

                        task.wait(0.5)

                        hrp.CFrame = originalCFrame
                        task.wait(0.3)
                    end
                end
            end)
        end
    end
})

-- Fly System
local flying = false
local flyForce, flyGyro
local FlySpeed = 1.5

local function StartFly()
    local char = player.Character
    if not char then return end

    local human = char:FindFirstChildOfClass("Humanoid")
    local root = char:FindFirstChild("HumanoidRootPart")
    if not human or not root then return end

    flying = true

    flyForce = Instance.new("BodyVelocity")
    flyGyro = Instance.new("BodyGyro")

    flyGyro.P = 10000
    flyGyro.MaxTorque = Vector3.new(10000, 10000, 10000)
    flyGyro.CFrame = root.CFrame

    flyForce.Velocity = Vector3.new()
    flyForce.MaxForce = Vector3.new(100000, 100000, 100000)

    flyForce.Parent = root
    flyGyro.Parent = root

    human.PlatformStand = true
    human.AutoRotate = false

    task.spawn(function()
        while flying do
            task.wait()

            local FV = workspace.CurrentCamera.CFrame:VectorToWorldSpace(Vector3.new(0, 0, -1))
            local SV = workspace.CurrentCamera.CFrame:VectorToWorldSpace(Vector3.new(-1, 0, 0))
            local move = human.MoveDirection

            local push =
                (FV * (60 * FlySpeed) * -move.Z)
                + (SV * (40 * FlySpeed) * -move.X)

            flyGyro.CFrame = CFrame.new(Vector3.new(), FV)
            flyForce.Velocity = flyForce.Velocity:Lerp(push, 0.2)
        end
    end)
end

local function StopFly()
    flying = false

    local char = player.Character
    if not char then return end
    local human = char:FindFirstChildOfClass("Humanoid")

    if flyForce then flyForce:Destroy() end
    if flyGyro then flyGyro:Destroy() end

    if human then
        human.PlatformStand = false
        human.AutoRotate = true
    end
end

MainTab:AddButton({
    Title = "Fly",
    Description = "Toggle fly system",
    Callback = function()
        flying = not flying
        if flying then
            StartFly()
        else
            StopFly()
        end
    end
})

MainTab:AddTextBox({
    Title = "Fly Speed",
    Default = tostring(FlySpeed),
    Placeholder = "1.5",
    Callback = function(txt)
        local num = tonumber(txt)
        if num then
            FlySpeed = num
        end
    end
})

-- Korblox and Headless
local extraStatus = {
    Korblox = false,
    Headless = false,
}

local function applyBodyMod()
    getgenv().Setting = {
        ["Body"] = {
            ["Korblox"] = extraStatus.Korblox,
            ["Headless"] = extraStatus.Headless,
        },
    }

    loadstring(game:HttpGet("https://raw.githubusercontent.com/khen791/script-khen/refs/heads/main/KorbloxAndHeadless.txt", true))()
end

player.CharacterAdded:Connect(function()
    task.wait(1)
    applyBodyMod()
end)

ExtraTab:AddToggle({
    Title = "Korblox",
    Description = "Toggle Korblox using link script",
    Value = false,
    Callback = function(state)
        extraStatus.Korblox = state
        applyBodyMod()
    end
})

ExtraTab:AddToggle({
    Title = "Headless",
    Description = "Toggle Headless using link script",
    Value = false,
    Callback = function(state)
        extraStatus.Headless = state
        applyBodyMod()
    end
})

-- Remove Darkness
ExtraTab:AddButton({
    Title = "Remove Darkness",
    Description = "Brighten map and remove shadows",
    Callback = function()
        local Lighting = game:GetService("Lighting")

        Lighting.Ambient = Color3.new(1,1,1)
        Lighting.OutdoorAmbient = Color3.new(1,1,1)
        Lighting.Brightness = 3
        Lighting.ExposureCompensation = 1

        Lighting.GlobalShadows = false

        for _, v in pairs(Lighting:GetChildren()) do
            if v:IsA("ColorCorrectionEffect")
            or v:IsA("DepthOfFieldEffect")
            or v:IsA("BloomEffect")
            or v:IsA("SunRaysEffect")
            or v:IsA("Atmosphere")
            or v:IsA("Sky") then
                v:Destroy()
            end
        end
    end
})

-- Fake Edash
local fakeEdashRunning = false
local fakeEdashConnection

ExtraTab:AddButton({
    Title = "Fake Edash 100 Style (Others)",
    Description = "Toggle fake edash script",
    Callback = function()
        if not fakeEdashRunning then
            fakeEdashRunning = true
            print("Fake Edash Started!")

            local source = game:HttpGet("https://raw.githubusercontent.com/G4V3S/S/refs/heads/main/fake%20edash.lua")
            fakeEdashConnection = loadstring(source)

            task.spawn(function()
                pcall(fakeEdashConnection)
            end)

        else
            fakeEdashRunning = false
            print("Fake Edash Stopped!")

            fakeEdashConnection = nil
        end
    end
})

-- Auto Trim/Bounce
local bounceEnabled = false
local bounceHeight = 100
local bounceDistance = 8

local function isNearGround(hrp)
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = {hrp.Parent}

    local offsets = {
        Vector3.new(0,-bounceDistance,0),
        Vector3.new(2,-bounceDistance,0),
        Vector3.new(-2,-bounceDistance,0),
        Vector3.new(0,-bounceDistance,2),
        Vector3.new(0,-bounceDistance,-2)
    }

    for _,offset in ipairs(offsets) do
        local r = workspace:Raycast(hrp.Position, offset, rayParams)
        if r and r.Instance and r.Instance.CanCollide then
            return true
        end
    end
    return false
end

task.spawn(function()
    while true do
        if bounceEnabled then
            local char = player.Character
            if char then
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp then
                    
                    local vel = hrp.Velocity
                    if vel.Y < -35 and isNearGround(hrp) then
                        hrp.Velocity = Vector3.new(vel.X, bounceHeight, vel.Z)

                        local fx = Instance.new("ParticleEmitter")
                        fx.Texture = "rbxassetid://241594180"
                        fx.Lifetime = NumberRange.new(0.3)
                        fx.Speed = NumberRange.new(40)
                        fx.Rate = 200
                        fx.Parent = hrp
                        game:GetService("Debris"):AddItem(fx,0.3)
                    end
                end
            end
        end
        task.wait()
    end
end)

local floatingBounceButton2
local autoBounce2 = false

local function createBounceFloatingButton2()
    if floatingBounceButton2 then return end

    floatingBounceButton2 = Instance.new("TextButton")
    floatingBounceButton2.Size = UDim2.new(0,100,0,50)
    floatingBounceButton2.Position = UDim2.new(0.5,-50,0.85,0)
    floatingBounceButton2.AnchorPoint = Vector2.new(0.5,0)
    floatingBounceButton2.BackgroundColor3 = Color3.fromRGB(255,0,150)
    floatingBounceButton2.TextColor3 = Color3.fromRGB(255,255,255)
    floatingBounceButton2.Text = autoBounce2 and "Auto Bounce: ON" or "Auto Bounce: OFF"
    floatingBounceButton2.Parent = FloatingGui

    floatingBounceButton2.Active = true
    floatingBounceButton2.Draggable = true

    floatingBounceButton2.MouseButton1Click:Connect(function()
        autoBounce2 = not autoBounce2
        bounceEnabled = autoBounce2
        floatingBounceButton2.Text = autoBounce2 and "Auto Bounce: ON" or "Auto Bounce: OFF"
    end)
end

MainTab:AddToggle({
    Title = "Auto Trim",
    Description = "Auto bounce with accurate ground check",
    Value = false,
    Callback = function(v)
        bounceEnabled = v
    end
})

MainTab:AddToggle({
    Title = "Auto Bounce (Floating Button)",
    Description = "Show floating button for Auto Bounce (more accurate)",
    Value = false,
    Callback = function(state)
        if state then 
            createBounceFloatingButton2()
        else
            if floatingBounceButton2 then
                floatingBounceButton2:Destroy()
                floatingBounceButton2 = nil
            end
            autoBounce2 = false
            bounceEnabled = false
        end
    end
})

-- Emote Script
ExtraTab:AddToggle({
    Title = "Show Emote Folder (Emote Script)",
    Description = "Run Emote script from Pastebin",
    Callback = function()
        local url = "https://pastebin.com/raw/DSZCMGqh"
        local success, err = pcall(function()
            loadstring(game:HttpGet(url))()
        end)
        if not success then
            warn("Cannot run Emote script: "..tostring(err))
        end
    end
})

-- Screen Stretch
getgenv().ScreenStretchActive = false
getgenv().Resolution = { [".gg/scripters"] = 0.65 }
local Camera = workspace.CurrentCamera
local ScreenStretchConn

ExtraTab:AddToggle({
    Title = "Screen Stretch",
    Description = "Toggle adjust camera Y axis",
    Value = false,
    Callback = function(state)
        if state then
            if not ScreenStretchConn then
                getgenv().ScreenStretchActive = true
                ScreenStretchConn = game:GetService("RunService").RenderStepped:Connect(function()
                    if Camera and getgenv().ScreenStretchActive then
                        Camera.CFrame = Camera.CFrame * CFrame.new(0, 0, 0, 1, 0, 0, 0, getgenv().Resolution[".gg/scripters"], 0, 0, 0, 1)
                    end
                end)
            end
            print("Screen Stretch Enabled")
        else
            getgenv().ScreenStretchActive = false
            if ScreenStretchConn then
                ScreenStretchConn:Disconnect()
                ScreenStretchConn = nil
            end
            print("Screen Stretch Disabled")
        end
    end
})

-- Auto Revive Friends
local autoReviveEnabled = false
local reviveRange = 15
local reviveLoop

local function isPlayerDowned(plr)
    if not plr.Character then return false end
    return plr.Character:GetAttribute("Downed") == true
end

local function startAutoRevive2()
    if reviveLoop then return end

    reviveLoop = game:GetService("RunService").Heartbeat:Connect(function()
        if not autoReviveEnabled then return end

        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        for _, pl in ipairs(Players:GetPlayers()) do
            if pl ~= player and isPlayerDowned(pl) then
                local pChar = pl.Character
                local pHrp = pChar and pChar:FindFirstChild("HumanoidRootPart")
                if pHrp then
                    local dist = (hrp.Position - pHrp.Position).Magnitude
                    if dist <= reviveRange then
                        pcall(function()
                            game:GetService("ReplicatedStorage"):WaitForChild("Events")
                                :WaitForChild("Character")
                                :WaitForChild("Interact")
                                :FireServer("Revive", true, pl.Name)
                        end)
                    end
                end
            end
        end
    end)
end

local function stopAutoRevive2()
    autoReviveEnabled = false
    if reviveLoop then
        reviveLoop:Disconnect()
        reviveLoop = nil
    end
end

MainTab:AddToggle({
    Title = "Auto Revive Friends",
    Description = "Auto revive downed players when nearby",
    Callback = function(state)
        autoReviveEnabled = state
        if state then
            startAutoRevive2()
        else
            stopAutoRevive2()
        end
    end
})

-- AFK Money (New)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer

local REVIVE_RANGE = 15
local REVIVE_CHECK_DELAY = 0.3
local AFK_TELEPORT_DELAY = 1.5
local AFK_HEIGHT = 1200

local autoReviveEnabled2 = false
local afkMoneyEnabled = false

local reviveLoop2 = nil
local afkLoop = nil
local afkPart2 = nil

local interactEvent =
ReplicatedStorage:WaitForChild("Events")
:WaitForChild("Character")
:WaitForChild("Interact")

local function isDowned(plr)
local char = plr.Character
if not char then return false end
return char:GetAttribute("Downed") == true
end

local function createAFKPart()
if afkPart2 then return end

afkPart2 = Instance.new("Part")  
afkPart2.Name = "AFK_PART"  
afkPart2.Size = Vector3.new(25, 2, 25)  
afkPart2.Anchored = true  
afkPart2.CanCollide = true  
afkPart2.Material = Enum.Material.Neon  
afkPart2.Color = Color3.fromRGB(0, 170, 255)  
afkPart2.Position = Vector3.new(0, AFK_HEIGHT, 0)  
afkPart2.Parent = workspace

end

local function tpToAFKPart(hrp)
if afkPart2 and hrp then
hrp.CFrame = afkPart2.CFrame + Vector3.new(0, 3, 0)
end
end

local function startAutoRevive3()
if reviveLoop2 then return end

reviveLoop2 = task.spawn(function()  
    while autoReviveEnabled2 do  
        local char = LocalPlayer.Character  
        local hrp = char and char:FindFirstChild("HumanoidRootPart")  

        if hrp then  
            for _, pl in ipairs(Players:GetPlayers()) do  
                if pl ~= LocalPlayer and isDowned(pl) then  
                    local pChar = pl.Character  
                    local pHrp = pChar and pChar:FindFirstChild("HumanoidRootPart")  
                    if pHrp then  
                        local dist = (hrp.Position - pHrp.Position).Magnitude  
                        if dist <= REVIVE_RANGE then  
                            pcall(function()  
                                interactEvent:FireServer("Revive", true, pl.Name)  
                            end)  
                        end  
                    end  
                end  
            end  
        end  

        task.wait(REVIVE_CHECK_DELAY)  
    end  
    reviveLoop2 = nil  
end)

end

local function stopAutoRevive3()
autoReviveEnabled2 = false
end

local function startAFKMoney()
if afkLoop then return end

createAFKPart()  

afkLoop = task.spawn(function()  
    while afkMoneyEnabled do  
        local char = LocalPlayer.Character  
        local hrp = char and char:FindFirstChild("HumanoidRootPart")  

        if not hrp then  
            task.wait(0.5)  
            continue  
        end  

        local found = false  

        for _, pl in ipairs(Players:GetPlayers()) do  
            if pl ~= LocalPlayer and isDowned(pl) then  
                local pChar = pl.Character  
                local pHrp = pChar and pChar:FindFirstChild("HumanoidRootPart")  
                if pHrp then  
                    found = true  
                    repeat  
                        hrp.CFrame = pHrp.CFrame + Vector3.new(0, 3, 0)  
                        pcall(function()  
                            interactEvent:FireServer("Revive", true, pl.Name)  
                        end)  
                        task.wait(0.4)  
                    until not isDowned(pl) or not afkMoneyEnabled  
                end  
            end  
        end  

        if not found then  
            tpToAFKPart(hrp)  
        end  

        task.wait(AFK_TELEPORT_DELAY)  
    end  
    afkLoop = nil  
end)

end

local function stopAFKMoney()
afkMoneyEnabled = false
if afkPart2 then
afkPart2:Destroy()
afkPart2 = nil
end
end

LocalPlayer.CharacterAdded:Connect(function(char)
if not afkMoneyEnabled then return end

task.spawn(function()  
    local hrp = char:WaitForChild("HumanoidRootPart", 10)  
    local hum = char:WaitForChild("Humanoid", 10)  
    if not hrp or not hum then return end  

    for i = 1, 5 do  
        if afkPart2 then  
            hrp.CFrame = afkPart2.CFrame + Vector3.new(0, 3, 0)  
        end  
        task.wait(0.3)  
    end  

    hum.StateChanged:Connect(function(_, new)  
        if afkMoneyEnabled and afkPart2 then  
            if new == Enum.HumanoidStateType.Running  
            or new == Enum.HumanoidStateType.RunningNoPhysics then  
                task.wait(0.1)  
                hrp.CFrame = afkPart2.CFrame + Vector3.new(0, 3, 0)  
            end  
        end  
    end)  
end)

end)

TeleportTab:AddToggle({
Title = "Auto Revive",
Description = "Revive nearby downed friends",
Callback = function(state)
autoReviveEnabled2 = state
if state then
startAutoRevive3()
else
stopAutoRevive3()
end
end
})

TeleportTab:AddToggle({
Title = "AFK Money (New)",
Description = "Create Part + auto warp revive",
Callback = function(state)
afkMoneyEnabled = state
if state then
startAFKMoney()
else
stopAFKMoney()
end
end
})

-- Anti-Kick Script
local url = "https://pastebin.com/raw/0TVwujLr"

local success, err = pcall(function()
    loadstring(game:HttpGet(url))()
end)

if success then
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local PlayerGui = player:WaitForChild("PlayerGui")

    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "NotifyScript"
    ScreenGui.ResetOnSpawn = false
    ScreenGui.Parent = PlayerGui

    local TextLabel = Instance.new("TextLabel")
    TextLabel.Size = UDim2.new(0,300,0,50)
    TextLabel.Position = UDim2.new(0.5,-150,0.1,0)
    TextLabel.BackgroundTransparency = 0.5
    TextLabel.BackgroundColor3 = Color3.fromRGB(0,0,0)
    TextLabel.TextColor3 = Color3.fromRGB(0,255,0)
    TextLabel.TextScaled = true
    TextLabel.Text = "Anti-Kick Active âœ…"
    TextLabel.Parent = ScreenGui

    task.delay(3, function()
        if ScreenGui then
            ScreenGui:Destroy()
        end
    end)
else
    warn("Cannot run script from Pastebin: "..tostring(err))
end

-- Camera System
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

local camPart
local partEnabled = false
local viewEnabled = false

local function createCameraPart()
	local char = player.Character
	if not char then return end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	camPart = Instance.new("Part")
	camPart.Name = "CameraPart"
	camPart.Size = Vector3.new(2,2,2)
	camPart.Anchored = true
	camPart.CanCollide = false
	camPart.Material = Enum.Material.SmoothPlastic
	camPart.Color = Color3.fromRGB(0,0,0)

	local cf = camera.CFrame
	camPart.CFrame = cf + (cf.LookVector * 6)
	camPart.Parent = workspace
end

SettingsTab:AddButton({
	Title = "Create / Delete Camera",
	Description = "Create camera part in front (press again to delete)",
	Callback = function()
		if not partEnabled then
			createCameraPart()
			partEnabled = true
		else
			if camPart then
				camPart:Destroy()
				camPart = nil
			end
			partEnabled = false

			if viewEnabled then
				camera.CameraType = Enum.CameraType.Custom
				if player.Character then
					camera.CameraSubject = player.Character:FindFirstChild("Humanoid")
				end
				viewEnabled = false
			end
		end
	end
})

SettingsTab:AddButton({
	Title = "Switch Camera View",
	Description = "Camera â†” Character",
	Callback = function()
		if not camPart then return end

		if not viewEnabled then
			camera.CameraType = Enum.CameraType.Scriptable
			camera.CFrame = camPart.CFrame
			viewEnabled = true
		else
			camera.CameraType = Enum.CameraType.Custom
			if player.Character then
				camera.CameraSubject = player.Character:FindFirstChild("Humanoid")
			end
			viewEnabled = false
		end
	end
})

RunService.RenderStepped:Connect(function()
	if viewEnabled and camPart then
		camera.CFrame = camPart.CFrame
	end
end)

player.CharacterAdded:Connect(function(char)
	task.wait(0.2)
	camera.CameraType = Enum.CameraType.Custom
	camera.CameraSubject = char:WaitForChild("Humanoid")
	viewEnabled = false
end)

print("âœ… KOMAT Hub Loaded Successfully!")
