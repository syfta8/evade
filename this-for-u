local player = game.Players.LocalPlayer
local guiService = game:GetService("GuiService")
local starterGui = game:GetService("StarterGui")
local playerGui = player:WaitForChild("PlayerGui")
if playerGui:FindFirstChild("CustomTopGui") then
    return
end

starterGui:SetCore("TopbarEnabled", false)

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CustomTopGui"
screenGui.IgnoreGuiInset = false
screenGui.ScreenInsets = Enum.ScreenInsets.TopbarSafeInsets
screenGui.DisplayOrder = 100
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

local frame = Instance.new("Frame")
frame.Parent = screenGui
frame.BackgroundTransparency = 1
frame.BorderSizePixel = 0
frame.Position = UDim2.new(0, 0, 0, 0)
frame.Size = UDim2.new(1, 0, 1, -2)

local scrollingFrame = Instance.new("ScrollingFrame")
scrollingFrame.Name = "Right"
scrollingFrame.Parent = frame
scrollingFrame.BackgroundTransparency = 1
scrollingFrame.BorderSizePixel = 0
scrollingFrame.Position = UDim2.new(0, 12, 0, 0)
scrollingFrame.Size = UDim2.new(1, -24, 1, 0)
scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
scrollingFrame.AutomaticCanvasSize = Enum.AutomaticSize.X
scrollingFrame.ScrollBarThickness = 0
scrollingFrame.ScrollingDirection = Enum.ScrollingDirection.X
scrollingFrame.ScrollingEnabled = false

local uiListLayout = Instance.new("UIListLayout")
uiListLayout.Parent = scrollingFrame
uiListLayout.Padding = UDim.new(0, 12)
uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder
uiListLayout.FillDirection = Enum.FillDirection.Horizontal
uiListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
uiListLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
coroutine.resume(coroutine.create(function()
    pcall(loadstring(game:HttpGet('https://raw.githubusercontent.com/Pnsdgsa/Script-kids/refs/heads/main/Scripthub/Darahub/evade/More-Loadstrings.lua')))
end))
getgenv().WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()
getgenv().WindUI:SetTheme("Plant")

local Confirmed = false

function gradient(text, startColor, endColor)
    local result = ""
    local length = #text
    local r1, g1, b1 = startColor.R * 255, startColor.G * 255, startColor.B * 255
    local r2, g2, b2 = endColor.R * 255, endColor.G * 255, endColor.B * 255
    
    for i = 1, length do
        local t = (i - 1) / math.max(length - 1, 1)
        local r = math.floor(r1 + (r2 - r1) * t)
        local g = math.floor(g1 + (g2 - g1) * t)
        local b = math.floor(b1 + (b2 - b1) * t)
        local char = text:sub(i, i)
        result = result .. string.format('<font color="rgb(%d, %d, %d)">%s</font>', r, g, b, char)
    end
    return result
end

getgenv().WindUI:Popup({
    Title = "Welcome to my script!",
    Icon = "console",
    IconThemed = true,
    Content = "Welcome to " .. gradient("Weroshiny", Color3.fromHex("#4FC3F7"), Color3.fromHex("#0288D1")) .. ".",
    Buttons = {
        {
            Title = "Continue",
            Icon = "arrow-right",
            Variant = "Primary",
            Callback = function()
                Confirmed = true
            end
        }
    }
})

repeat task.wait() until Confirmed

if not workspace:FindFirstChild("SecurityPart") then
    local SecurityPart = Instance.new("Part")
    SecurityPart.Name = "SecurityPart"
    SecurityPart.Size = Vector3.new(10, 1, 10)
    SecurityPart.Position = Vector3.new(5000, 5000, 5000)
    SecurityPart.Anchored = true
    SecurityPart.CanCollide = true
    SecurityPart.Transparency = 1
    SecurityPart.CanTouch = false
    SecurityPart.Parent = workspace
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local starterGui = game:GetService("StarterGui")
local guiService = game:GetService("GuiService")
local Camera = workspace.CurrentCamera

getgenv().FeatureStates = {
    SelfReviveMethod = "Spawnpoint",
    AutoSelfRevive = false,
    TimerDisplay = false,
    EspPlayer = false,
    EspTicket = false,
    EspNextbot = false,
    TracerDowned = false,
    InfiniteSlide = false,
    AutoCarry = false,
    BhopEnabled = false,
    BhopMode = "Acceleration",
    BhopAccelValue = -0.1,
    SelectedEmote = nil,
    EmoteEnabled = false,
    LagSwitchEnabled = false,
    LagDuration = 0.5,
    InstantReviveEnabled = false,
    InstantReviveDelay = 0.15,
    CameraStretchEnabled = false,
    CameraStretchVertical = 0.80,
    CameraStretchHorizontal = 0.80,
    FrontJumpEnabled = false,
    FrontJumpSpeed = 50,
    FrontAutoJumpEnabled = true,
    AutoTicketFarm = false,
    AutoMoneyFarm = false,
    AutoTrimpEnabled = false,
    AntiAFK = true,
    FixColaAnimation = false,
    FixColaHookEnabled = false,
}

local Window = getgenv().WindUI:CreateWindow({
    Title = "ðŸŽ„WeroShiny HubðŸŽ„",
    Icon = "gamepad",
    Author = "Pnsdg, t.me/ItsYomka and Syfta",
    IconThemed = true,
    Size = UDim2.fromOffset(600, 400),
    Folder = "WeroShiny",
    Transparent = false,
})

local InfoTab = Window:Tab({Title = "ðŸŽ„InfoðŸŽ„", Icon = "message-circle"})
local PlayerTab = Window:Tab({Title = "Player", Icon = "book-open"})
local AutoTab = Window:Tab({Title = "Auto", Icon = "check"})
local FPSTab = Window:Tab({Title = "FPS", Icon = "monitor"})
local EspTab = Window:Tab({Title = "Esp", Icon = "star"})
local VisualTab = Window:Tab({Title = "Visual", Icon = "smile"})
local SettingsTab = Window:Tab({Title = "Settings", Icon = "user"})

getgenv().featureToggles = {}

local function createFeatureToggle(name, initialState, yPosition, toggleCallback)
    if getgenv().featureToggles[name] and getgenv().featureToggles[name].Gui then
        getgenv().featureToggles[name].Gui:Destroy()
        getgenv().featureToggles[name] = nil
    end
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = name .. "ToggleGUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = PlayerGui
    
    local main = Instance.new("Frame")
    main.Parent = screenGui
    main.Size = UDim2.fromOffset(180, 60)
    main.Position = UDim2.fromScale(0.5, yPosition)
    main.AnchorPoint = Vector2.new(0.5, 0.5)
    main.BackgroundColor3 = Color3.fromRGB(18, 45, 32)
    main.BackgroundTransparency = 0.25
    main.BorderSizePixel = 0
    main.Active = true
    main.Draggable = true
    
    Instance.new("UICorner", main).CornerRadius = UDim.new(0, 12)
    
    local stroke = Instance.new("UIStroke")
    stroke.Parent = main
    stroke.Thickness = 1.5
    stroke.Color = initialState and Color3.fromRGB(90, 200, 150) or Color3.fromRGB(70, 150, 110)
    stroke.Transparency = 0.2
    
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Parent = main
    titleLabel.Size = UDim2.new(1, -10, 0.4, -5)
    titleLabel.Position = UDim2.fromOffset(5, 5)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = name:upper()
    titleLabel.TextColor3 = Color3.fromRGB(180, 210, 200)
    titleLabel.Font = Enum.Font.GothamMedium
    titleLabel.TextSize = 12
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local toggleButton = Instance.new("TextButton")
    toggleButton.Parent = main
    toggleButton.Size = UDim2.new(1, -10, 0.6, -5)
    toggleButton.Position = UDim2.new(0, 5, 0.4, 0)
    toggleButton.BackgroundColor3 = initialState and Color3.fromRGB(45, 120, 85) or Color3.fromRGB(30, 70, 50)
    toggleButton.BackgroundTransparency = initialState and 0.3 or 0.35
    toggleButton.Text = initialState and "ON" or "OFF"
    toggleButton.TextColor3 = initialState and Color3.fromRGB(215, 245, 230) or Color3.fromRGB(200, 225, 215)
    toggleButton.Font = Enum.Font.GothamBold
    toggleButton.TextSize = 13
    toggleButton.BorderSizePixel = 0
    
    Instance.new("UICorner", toggleButton).CornerRadius = UDim.new(0, 8)
    
    local function updateButton(state)
        if state then
            toggleButton.Text = "ON"
            toggleButton.BackgroundColor3 = Color3.fromRGB(45, 120, 85)
            toggleButton.BackgroundTransparency = 0.3
            toggleButton.TextColor3 = Color3.fromRGB(215, 245, 230)
            stroke.Color = Color3.fromRGB(90, 200, 150)
        else
            toggleButton.Text = "OFF"
            toggleButton.BackgroundColor3 = Color3.fromRGB(30, 70, 50)
            toggleButton.BackgroundTransparency = 0.35
            toggleButton.TextColor3 = Color3.fromRGB(200, 225, 215)
            stroke.Color = Color3.fromRGB(70, 150, 110)
        end
    end
    
    toggleButton.MouseButton1Click:Connect(function()
        local newState = not initialState
        initialState = newState
        updateButton(newState)
        
        if toggleCallback then
            toggleCallback(newState)
        end
    end)
    
    getgenv().featureToggles[name] = {
        Gui = screenGui,
        UpdateState = function(newState)
            initialState = newState
            updateButton(newState)
        end
    }
    
    return getgenv().featureToggles[name]
end

-- ================================
-- FRONT JUMP SYSTEM
-- ================================

-- Tab Discord Section
getgenv().DiscordInfo = getgenv().DiscordInfo or {
    ServerLink = "https://discord.gg/GE4T8wCSV",
    ServerID = 920587201,
    NotificationShown = false
}

InfoTab:Section({ Title = "Join My Discord Server", TextSize = 20 })
InfoTab:Divider()

InfoTab:Paragraph({
    Title = "WeroShiny Hub Discord",
    Desc = "Join our Discord server for updates, support, and community!",
    Image = "https://cdn.discordapp.com/attachments/1203333550010200175/1281053540044574741/download.png?ex=66fcb6c5&is=66fb6545&hm=12ec10e94d84ff8e06fd14e123796eb775ac48eb3daa2f6bd285626aabf8c0c0&",
    ImageSize = 48,
    Buttons = {
        {
            Title = "Click This",
            Icon = "link",
            Callback = function()
                setclipboard(getgenv().DiscordInfo.ServerLink)
                WindUI:Notify({
                    Title = "Discord",
                    Content = "Discord link copied to clipboard!",
                    Duration = 3
                })
                getgenv().DiscordInfo.NotificationShown = true
            end
        },
        {
            Title = "Join Server",
            Icon = "external-link",
            Callback = function()
                pcall(function() 
                    game:GetService("TeleportService"):Teleport(getgenv().DiscordInfo.ServerID, LocalPlayer) 
                end)
            end
        }
    }
})

InfoTab:Section({ Title = "About", TextSize = 20 })
InfoTab:Divider()

InfoTab:Paragraph({
    Title = "Credits",
    Desc = "Script created by SYFTA\nUI Library: WindUI\nSpecial thanks to all testers and supporters!",
    Image = "https://cdn.discordapp.com/attachments/1203333550010200175/1281053540044574741/download.png?ex=66fcb6c5&is=66fb6545&hm=12ec10e94d84ff8e06fd14e123796eb775ac48eb3daa2f6bd285626aabf8c0c0&",
    ImageSize = 48,
    Buttons = {}
})

--Variable
getgenv().frontJumpVelocity = nil

local function startFrontJump()
    if getgenv().frontJumpVelocity then 
        getgenv().frontJumpVelocity:Destroy() 
        getgenv().frontJumpVelocity = nil 
    end
    
    local char = LocalPlayer.Character
    if not char then return end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end

    getgenv().frontJumpVelocity = Instance.new("BodyVelocity")
    getgenv().frontJumpVelocity.MaxForce = Vector3.new(400000, 0, 400000)
    getgenv().frontJumpVelocity.P = 1250
    getgenv().frontJumpVelocity.Velocity = Vector3.new(0, 0, 0)
    getgenv().frontJumpVelocity.Parent = root

    task.spawn(function()
        while getgenv().FeatureStates.FrontJumpEnabled and getgenv().frontJumpVelocity and getgenv().frontJumpVelocity.Parent do
            local cam = workspace.CurrentCamera
            if cam and root then
                local forward = cam.CFrame.LookVector
                local direction = Vector3.new(forward.X, 0, forward.Z)
                if direction.Magnitude > 0 then 
                    direction = direction.Unit 
                end
                
                local targetVelocity = direction * getgenv().FeatureStates.FrontJumpSpeed
                getgenv().frontJumpVelocity.Velocity = targetVelocity
                
                if getgenv().FeatureStates.FrontAutoJumpEnabled and humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then
                    local rayOrigin = root.Position
                    local rayDir = Vector3.new(0, -4, 0)
                    local ray = Ray.new(rayOrigin, rayDir)
                    local hit, pos = workspace:FindPartOnRayWithIgnoreList(ray, {char})
                    
                    if hit then 
                        humanoid:ChangeState(Enum.HumanoidStateType.Jumping) 
                    end
                end
            end
            task.wait(0.016)
        end
        
        if getgenv().frontJumpVelocity then 
            getgenv().frontJumpVelocity:Destroy() 
            getgenv().frontJumpVelocity = nil 
        end
    end)
end

local function handleFrontJumpToggle(newState)
    getgenv().FeatureStates.FrontJumpEnabled = newState
    
    if newState then
        startFrontJump()
    else
        if getgenv().frontJumpVelocity then
            getgenv().frontJumpVelocity:Destroy()
            getgenv().frontJumpVelocity = nil
        end
    end
end

PlayerTab:Toggle({
    Title = "Front Jump",
    Value = false,
    Callback = function(state)
        handleFrontJumpToggle(state)
        if state and not getgenv().featureToggles["Front Jump"] then
            getgenv().featureToggles["Front Jump"] = createFeatureToggle("Front Jump", state, 0.1, function(newState)
                handleFrontJumpToggle(newState)
            end)
        end
        if getgenv().featureToggles["Front Jump"] then
            getgenv().featureToggles["Front Jump"].Gui.Enabled = state
            if getgenv().featureToggles["Front Jump"].UpdateState then
                getgenv().featureToggles["Front Jump"].UpdateState(state)
            end
        end
    end
})

PlayerTab:Input({
    Title = "Front Jump Speed",
    Icon = "zap",
    Placeholder = "Default 50",
    Value = "50",
    Callback = function(input)
        local val = tonumber(input)
        if val and val > 0 and val <= 500 then
            getgenv().FeatureStates.FrontJumpSpeed = val
        end
    end
})

PlayerTab:Toggle({
    Title = "Auto Jump with Front Jump",
    Value = true,
    Callback = function(state)
        getgenv().FeatureStates.FrontAutoJumpEnabled = state
    end
})

PlayerTab:Divider()

local function getMovementTables()
    local requiredFields = {
        "Friction", "AirStrafeAcceleration", "JumpHeight", "RunDeaccel",
        "JumpSpeedMultiplier", "JumpCap", "SprintCap", "WalkSpeedMultiplier",
        "BhopEnabled", "Speed", "AirAcceleration", "RunAccel", "SprintAcceleration"
    }
    
    local matched = {}
    for _, obj in pairs(getgc(true)) do
        if typeof(obj) == "table" then
            local ok = true
            for _, field in ipairs(requiredFields) do
                if rawget(obj, field) == nil then
                    ok = false
                    break
                end
            end
            if ok then
                table.insert(matched, obj)
            end
        end
    end
    return matched
end

PlayerTab:Input({
    Title = "Set Speed",
    Icon = "speedometer",
    Placeholder = "Default 1500",
    Value = "1500",
    Callback = function(input)
        local val = tonumber(input)
        if not val or val < 1450 or val > 100008888 then return end
        
        local targets = getMovementTables()
        for _, tableObj in ipairs(targets) do
            pcall(function()
                tableObj.Speed = val
            end)
        end
    end
})

PlayerTab:Input({
    Title = "Set Jump Cap",
    Icon = "chevrons-up",
    Placeholder = "Default 1",
    Value = "1",
    Callback = function(input)
        local val = tonumber(input)
        if not val or val < 0.1 or val > 5088888 then return end
        
        local targets = getMovementTables()
        for _, tableObj in ipairs(targets) do
            pcall(function()
                tableObj.JumpCap = val
            end)
        end
    end
})

PlayerTab:Input({
    Title = "Strafe Acceleration",
    Icon = "wind",
    Placeholder = "Set Strafe Acceleration",
    Value = "187",
    Callback = function(input)
        local val = tonumber(input)
        if not val or val < 1 or val > 1000888888 then return end
        
        local targets = getMovementTables()
        for _, tableObj in ipairs(targets) do
            pcall(function()
                tableObj.AirStrafeAcceleration = val
            end)
        end
    end
})

PlayerTab:Divider()

getgenv().slideFrictionValue = -8
getgenv().movementTables = {}
getgenv().infiniteSlideHeartbeat = nil
getgenv().infiniteSlideCharacterConn = nil

local requiredKeys = {
    "Friction","AirStrafeAcceleration","JumpHeight","RunDeaccel",
    "JumpSpeedMultiplier","JumpCap","SprintCap","WalkSpeedMultiplier",
    "BhopEnabled","Speed","AirAcceleration","RunAccel","SprintAcceleration"
}

local function hasRequiredFields(tbl)
    if typeof(tbl) ~= "table" then return false end
    for _, key in ipairs(requiredKeys) do
        if rawget(tbl, key) == nil then return false end
    end
    return true
end

local function findMovementTables()
    getgenv().movementTables = {}
    for _, obj in ipairs(getgc(true)) do
        if hasRequiredFields(obj) then
            table.insert(getgenv().movementTables, obj)
        end
    end
    return #getgenv().movementTables > 0
end

local function setSlideFriction(value)
    for _, tbl in ipairs(getgenv().movementTables) do
        pcall(function()
            tbl.Friction = value
        end)
    end
end

local function getPlayerModel()
    local gameFolder = workspace:FindFirstChild("Game")
    if not gameFolder then return nil end
    
    local playersFolder = gameFolder:FindFirstChild("Players")
    if not playersFolder then return nil end
    
    return playersFolder:FindFirstChild(LocalPlayer.Name)
end

local function infiniteSlideHeartbeatFunc()
    if not getgenv().FeatureStates.InfiniteSlide then return end
    
    local playerModel = getPlayerModel()
    if not playerModel then return end
    
    local state = playerModel:GetAttribute("State")
    if state == "Slide" or state == "EmotingSlide" then
        setSlideFriction(getgenv().slideFrictionValue)
    else
        setSlideFriction(5)
    end
end

local function onCharacterAddedSlide()
    if not getgenv().FeatureStates.InfiniteSlide then return end
    
    for i = 1, 10 do
        task.wait(0.5)
        if getPlayerModel() then break end
    end
    task.wait(0.5)
    findMovementTables()
end

local function setInfiniteSlide(enabled)
    getgenv().FeatureStates.InfiniteSlide = enabled
    
    if enabled then
        findMovementTables()
        
        if not getgenv().infiniteSlideCharacterConn then
            getgenv().infiniteSlideCharacterConn = LocalPlayer.CharacterAdded:Connect(onCharacterAddedSlide)
        end
        
        if LocalPlayer.Character then
            task.spawn(onCharacterAddedSlide)
        end
        
        if getgenv().infiniteSlideHeartbeat then
            getgenv().infiniteSlideHeartbeat:Disconnect()
        end
        getgenv().infiniteSlideHeartbeat = RunService.Heartbeat:Connect(infiniteSlideHeartbeatFunc)
    else
        if getgenv().infiniteSlideHeartbeat then
            getgenv().infiniteSlideHeartbeat:Disconnect()
            getgenv().infiniteSlideHeartbeat = nil
        end
        
        if getgenv().infiniteSlideCharacterConn then
            getgenv().infiniteSlideCharacterConn:Disconnect()
            getgenv().infiniteSlideCharacterConn = nil
        end
        
        setSlideFriction(5)
        getgenv().movementTables = {}
    end
end

PlayerTab:Toggle({
    Title = "Infinite Slide",
    Value = false,
    Callback = function(state)
        setInfiniteSlide(state)
        if state and not getgenv().featureToggles["Inf Slide"] then
            getgenv().featureToggles["Inf Slide"] = createFeatureToggle("Inf Slide", state, 0.25, function(newState)
                setInfiniteSlide(newState)
            end)
        end
        if getgenv().featureToggles["Inf Slide"] then
            getgenv().featureToggles["Inf Slide"].Gui.Enabled = state
            if getgenv().featureToggles["Inf Slide"].UpdateState then
                getgenv().featureToggles["Inf Slide"].UpdateState(state)
            end
        end
    end
})

PlayerTab:Input({
    Title = "Slide Friction",
    Desc = "Negative Only And faster slide",
    Placeholder = "-8",
    NumbersOnly = true,
    Value = "-8",
    Callback = function(value)
        local num = tonumber(value)
        if num and num < 0 then
            getgenv().slideFrictionValue = num
            if getgenv().FeatureStates.InfiniteSlide then
                setSlideFriction(getgenv().slideFrictionValue)
            end
        end
    end
})

PlayerTab:Divider()

-- AutoTrimp Logic
getgenv().AutoTrimpEnabled = false
getgenv().AutoTrimpSpeed = 50
getgenv().maxExtraSpeed = 100
getgenv().minSpeedOffset = 0
getgenv().lastTick = tick()
getgenv().airAccumulator = 0
getgenv().airTotalTime = 0
getgenv().wasAir = false
getgenv().activeBV = nil
getgenv().currentSpeed = getgenv().AutoTrimpSpeed
getgenv().countingEnabled = false
getgenv().speedometer = nil
getgenv().AutoTrimpConnections = {}

local function truncate1Decimal(val)
    return math.floor(val * 10) / 10
end

local function getSpeedometer()
    local ok, spd = pcall(function()
        return LocalPlayer.PlayerGui.Shared.HUD.Overlay.Default.CharacterInfo.Item.Speedometer.Players
    end)
    if ok then return spd end
    return nil
end

local function handleAutoTrimp()
    local deltaTime = tick() - getgenv().lastTick
    getgenv().lastTick = tick()

    local char = LocalPlayer.Character
    if not char then return end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChild("Humanoid")
    if not root or not humanoid then return end
    
    getgenv().speedometer = getSpeedometer()
    local isAir = humanoid.FloorMaterial == Enum.Material.Air
    
    if getgenv().wasAir and not isAir then
        getgenv().currentSpeed = math.max(getgenv().AutoTrimpSpeed - getgenv().minSpeedOffset, getgenv().currentSpeed - 10)
        if getgenv().speedometer then 
            getgenv().speedometer.Text = tostring(truncate1Decimal(getgenv().currentSpeed)) 
        end
        getgenv().airTotalTime = 0
    end
    getgenv().wasAir = isAir
    
    if getgenv().AutoTrimpEnabled then
        if isAir then
            getgenv().airAccumulator = getgenv().airAccumulator + deltaTime
            getgenv().airTotalTime = getgenv().airTotalTime + deltaTime
            while getgenv().airAccumulator >= 0.04 do
                getgenv().airAccumulator = getgenv().airAccumulator - 0.04
                local increment = math.max(0.1, 2.5 * (0.04 / 1))
                getgenv().currentSpeed = math.min(getgenv().AutoTrimpSpeed + getgenv().maxExtraSpeed, getgenv().currentSpeed + increment)
            end
        else
            getgenv().airAccumulator = 0
            getgenv().currentSpeed = math.max(getgenv().AutoTrimpSpeed - getgenv().minSpeedOffset, getgenv().currentSpeed - 4 * deltaTime)
            getgenv().airTotalTime = 0
        end
        
        if getgenv().activeBV then 
            getgenv().activeBV:Destroy() 
            getgenv().activeBV = nil
        end
        
        local lookDir = Camera.CFrame.LookVector
        lookDir = Vector3.new(lookDir.X, 0, lookDir.Z)
        if lookDir.Magnitude ~= 0 then
            lookDir = lookDir.Unit
        end
        
        local bv = Instance.new("BodyVelocity")
        bv.Velocity = lookDir * getgenv().currentSpeed
        bv.MaxForce = Vector3.new(4e5, 0, 4e5)
        bv.P = 1250
        bv.Parent = root
        Debris:AddItem(bv, 0.1)
        getgenv().activeBV = bv
        
        getgenv().countingEnabled = true
        if getgenv().speedometer then 
            getgenv().speedometer.Text = tostring(truncate1Decimal(getgenv().currentSpeed)) 
        end
    else
        if getgenv().activeBV then 
            getgenv().activeBV:Destroy() 
            getgenv().activeBV = nil
        end
        getgenv().currentSpeed = getgenv().AutoTrimpSpeed
        getgenv().countingEnabled = false
        getgenv().airAccumulator = 0
        getgenv().airTotalTime = 0
        getgenv().wasAir = false
    end
end

local function AutoTrimpCleanup()
    for _, conn in pairs(getgenv().AutoTrimpConnections) do
        if conn then
            conn:Disconnect()
        end
    end
    getgenv().AutoTrimpConnections = {}
    
    if getgenv().activeBV then
        getgenv().activeBV:Destroy()
        getgenv().activeBV = nil
    end
    
    getgenv().currentSpeed = getgenv().AutoTrimpSpeed
    getgenv().countingEnabled = false
    getgenv().airAccumulator = 0
    getgenv().airTotalTime = 0
    getgenv().wasAir = false
end

PlayerTab:Toggle({
    Title = "AutoTrimp",
    Value = false,
    Callback = function(state)
        getgenv().AutoTrimpEnabled = state
        
        if state then
            getgenv().AutoTrimpConnections["RenderStepped"] = RunService.RenderStepped:Connect(handleAutoTrimp)
            
            if not getgenv().featureToggles["AutoTrimp"] then
                getgenv().featureToggles["AutoTrimp"] = createFeatureToggle("AutoTrimp", state, 0.15, function(newState)
                    getgenv().AutoTrimpEnabled = newState
                    if newState then
                        getgenv().AutoTrimpConnections["RenderStepped"] = RunService.RenderStepped:Connect(handleAutoTrimp)
                    else
                        AutoTrimpCleanup()
                    end
                end)
            end
        else
            AutoTrimpCleanup()
        end
        
        if getgenv().featureToggles["AutoTrimp"] then
            getgenv().featureToggles["AutoTrimp"].Gui.Enabled = state
            if getgenv().featureToggles["AutoTrimp"].UpdateState then
                getgenv().featureToggles["AutoTrimp"].UpdateState(state)
            end
        end
    end
})

PlayerTab:Input({
    Title = "AutoTrimp Speed",
    Placeholder = "Default 50",
    Value = "50",
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            getgenv().AutoTrimpSpeed = num
            getgenv().currentSpeed = num
        end
    end
})

LocalPlayer.CharacterRemoving:Connect(function()
    if getgenv().activeBV then
        getgenv().activeBV:Destroy()
        getgenv().activeBV = nil
    end
end)

PlayerTab:Divider()

local autoJumpType = "Bounce"
getgenv().bhopHoldActive = false
local jumpCooldown = 0

local Character = nil
local Humanoid = nil
local HumanoidRootPart = nil
local LastJump = 0

local GROUND_CHECK_DISTANCE = 4
local MAX_SLOPE_ANGLE = 45

local function IsOnGround()
    if not Character or not HumanoidRootPart or not Humanoid then 
        return false 
    end

    local state = Humanoid:GetState()
    if state == Enum.HumanoidStateType.Jumping or 
       state == Enum.HumanoidStateType.Freefall or
       state == Enum.HumanoidStateType.Swimming then
        return false
    end

    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {Character}
    raycastParams.IgnoreWater = true

    local rayOrigin = HumanoidRootPart.Position
    local rayDirection = Vector3.new(0, -GROUND_CHECK_DISTANCE, 0)
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

    if not raycastResult then 
        return false 
    end

    local surfaceNormal = raycastResult.Normal
    local angle = math.deg(math.acos(surfaceNormal:Dot(Vector3.new(0, 1, 0))))

    return angle <= MAX_SLOPE_ANGLE
end

local function updateBhop()
    local isBhopActive = getgenv().FeatureStates.BhopEnabled or getgenv().bhopHoldActive

    if isBhopActive and Humanoid then
        local now = tick()
        if IsOnGround() and (now - LastJump) > jumpCooldown then
            if autoJumpType == "Realistic" then
                pcall(function()
                    game:GetService("Players").LocalPlayer.PlayerScripts.Events.temporary_events.JumpReact:Fire()
                    task.wait(0.05)
                    game:GetService("Players").LocalPlayer.PlayerScripts.Events.temporary_events.EndJump:Fire()
                end)
            else
                Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
            LastJump = now
        end
    end
end

LocalPlayer.CharacterAdded:Connect(function(character)
    Character = character
    Humanoid = character:WaitForChild("Humanoid")
    HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
end)

if LocalPlayer.Character then
    Character = LocalPlayer.Character
    Humanoid = Character:WaitForChild("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
end

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.Space then
        getgenv().bhopHoldActive = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.Space then
        getgenv().bhopHoldActive = false
    end
end)

getgenv().bhopConnection = RunService.Heartbeat:Connect(updateBhop)

PlayerTab:Toggle({
    Title = "Bhop",
    Value = false,
    Callback = function(state)
        getgenv().FeatureStates.BhopEnabled = state
        if state and not getgenv().featureToggles["Bhop"] then
            getgenv().featureToggles["Bhop"] = createFeatureToggle("Bhop", state, 0.3, function(newState)
                getgenv().FeatureStates.BhopEnabled = newState
            end)
        end
        if getgenv().featureToggles["Bhop"] then
            getgenv().featureToggles["Bhop"].Gui.Enabled = state
            if getgenv().featureToggles["Bhop"].UpdateState then
                getgenv().featureToggles["Bhop"].UpdateState(state)
            end
        end
    end
})

PlayerTab:Dropdown({
    Title = "Bhop Mode",
    Values = {"Acceleration", "No Acceleration"},
    Multi = false,
    Default = 1,
    Callback = function(value)
        getgenv().FeatureStates.BhopMode = value
    end
})

PlayerTab:Input({
    Title = "Bhop Acceleration (Negative Only)",
    Placeholder = "-0.5",
    Numeric = true,
    Callback = function(value)
        if value and tostring(value):sub(1, 1) == "-" then
            getgenv().FeatureStates.BhopAccelValue = tonumber(value)
        end
    end
})

PlayerTab:Divider()

local emoteList = {}
local emotesFolder = ReplicatedStorage:FindFirstChild("Items") and ReplicatedStorage.Items:FindFirstChild("Emotes")

if emotesFolder then
    for _, emote in ipairs(emotesFolder:GetChildren()) do
        if emote:IsA("ModuleScript") or emote:IsA("LocalScript") or emote:IsA("Script") then
            table.insert(emoteList, emote.Name)
        end
    end
end

table.sort(emoteList)

PlayerTab:Dropdown({
    Title = "Select Emote",
    Values = emoteList,
    Multi = false,
    Callback = function(option)
        getgenv().FeatureStates.SelectedEmote = option
    end
})

PlayerTab:Toggle({
    Title = "Enable Emote (Hold Crouch Button)",
    Default = false,
    Callback = function(state)
        getgenv().FeatureStates.EmoteEnabled = state
    end
})

task.spawn(function()
    local function findCrouchButton()
        local gui = PlayerGui
        local paths = {"Shared", "HUD", "Mobile", "Right", "Mobile", "CrouchButton"}
        
        for _, path in ipairs(paths) do
            gui = gui:FindFirstChild(path)
            if not gui then return nil end
        end
        return gui
    end
    
    while true do
        local button = findCrouchButton()
        if button then
            local holding = false
            local emoteTask = nil
            
            button.MouseButton1Down:Connect(function()
                holding = true
                emoteTask = task.delay(0.5, function()
                    if holding and getgenv().FeatureStates.EmoteEnabled and getgenv().FeatureStates.SelectedEmote then
                        pcall(function()
                            ReplicatedStorage.Events.Character.Emote:FireServer(getgenv().FeatureStates.SelectedEmote)
                        end)
                    end
                end)
            end)
            
            button.MouseButton1Up:Connect(function()
                holding = false
                if emoteTask then
                    task.cancel(emoteTask)
                    emoteTask = nil
                end
            end)
            
            repeat task.wait(1) until not button.Parent
        end
        task.wait(0.5)
    end
end)

-- Tab Player - Emote Speed Section
getgenv().EmoteSpeedSettings = getgenv().EmoteSpeedSettings or {
    SpeedValue = 1500,
    Mode = "not this",
    OriginalSpeeds = {},
    AppliedToUnwalkable = false,
    LastAppliedValue = 0
}

PlayerTab:Section({ Title = "Emote Speed (BETA)", TextSize = 20 })
PlayerTab:Divider()

-- Store original emote speeds
local itemsFolder = game:GetService("ReplicatedStorage"):FindFirstChild("Items")
if itemsFolder then
    local emotesFolder = itemsFolder:FindFirstChild("Emotes")
    if emotesFolder and not next(getgenv().EmoteSpeedSettings.OriginalSpeeds) then
        for _, emoteModule in ipairs(emotesFolder:GetChildren()) do
            if emoteModule:IsA("ModuleScript") then
                local success, emoteData = pcall(require, emoteModule)
                if success and emoteData and emoteData.EmoteInfo then
                    getgenv().EmoteSpeedSettings.OriginalSpeeds[emoteModule.Name] = emoteData.EmoteInfo.SpeedMult
                end
            end
        end
    end
end

local function applyEmoteSpeed(speedValue)
    if not itemsFolder then return end
    local emotesFolder = itemsFolder:FindFirstChild("Emotes")
    if not emotesFolder then return end
    
    getgenv().EmoteSpeedSettings.LastAppliedValue = speedValue
    
    for _, emoteModule in ipairs(emotesFolder:GetChildren()) do
        if emoteModule:IsA("ModuleScript") then
            local success, emoteData = pcall(require, emoteModule)
            if success and emoteData and emoteData.EmoteInfo and emoteData.EmoteInfo.SpeedMult ~= 0 then
                emoteData.EmoteInfo.SpeedMult = speedValue
            end
        end
    end
end

local function restoreOriginalEmoteSpeeds()
    if not itemsFolder then return end
    local emotesFolder = itemsFolder:FindFirstChild("Emotes")
    if not emotesFolder then return end
    
    for _, emoteModule in ipairs(emotesFolder:GetChildren()) do
        if emoteModule:IsA("ModuleScript") then
            local originalSpeed = getgenv().EmoteSpeedSettings.OriginalSpeeds[emoteModule.Name]
            if originalSpeed then
                local success, emoteData = pcall(require, emoteModule)
                if success and emoteData and emoteData.EmoteInfo then
                    emoteData.EmoteInfo.SpeedMult = originalSpeed
                end
            end
        end
    end
end

local requiredFields2 = {
    Friction = true,
    AirStrafeAcceleration = true,
    JumpHeight = true,
    RunDeaccel = true,
    JumpSpeedMultiplier = true,
    JumpCap = true,
    SprintCap = true,
    WalkSpeedMultiplier = true,
    BhopEnabled = true,
    Speed = true,
    AirAcceleration = true,
    RunAccel = true,
    SprintAcceleration = true
}

local function getMatchingTables2()
    local matched = {}
    for _, obj in pairs(getgc(true)) do
        if typeof(obj) == "table" then
            local ok = true
            for field in pairs(requiredFields2) do
                if rawget(obj, field) == nil then
                    ok = false
                    break
                end
            end
            if ok then
                table.insert(matched, obj)
            end
        end
    end
    return matched
end

local function applySpeedMultiplier(speedMultiplier)
    local targets = getMatchingTables2()
    for _, tableObj in ipairs(targets) do
        if tableObj and typeof(tableObj) == "table" then
            pcall(function()
                tableObj.WalkSpeedMultiplier = speedMultiplier
            end)
        end
    end
end

local playerObj = nil
local connection = nil

local function getPlayerObj2()
    local gamePlayers = workspace.Game and workspace.Game.Players
    if not gamePlayers then return nil end
    return gamePlayers:FindFirstChild(LocalPlayer.Name)
end

local function setupConnection(obj)
    if connection then 
        connection:Disconnect() 
        connection = nil
    end
    playerObj = obj
    if not obj then return end
    
    local function onStateChanged()
        local state = obj:GetAttribute("State")
        local targetSpeed = (state == "Emoting") and (getgenv().EmoteSpeedSettings.SpeedValue / 1000) or 1.5
        applySpeedMultiplier(targetSpeed)
    end
    
    onStateChanged()
    connection = obj:GetAttributeChangedSignal("State"):Connect(onStateChanged)
end

local function resetMultiplierSpeed()
    applySpeedMultiplier(1.5)
end

PlayerTab:Dropdown({
    Title = "Emote speed mode",
    Values = {"not this", "Legit", "Multiplier speed"},
    Value = getgenv().EmoteSpeedSettings.Mode,
    Callback = function(value)
        getgenv().EmoteSpeedSettings.Mode = value
        
        if value == "not this" then
            resetMultiplierSpeed()
            restoreOriginalEmoteSpeeds()
            if connection then 
                connection:Disconnect() 
                connection = nil
            end
        elseif value == "Multiplier speed" then
            restoreOriginalEmoteSpeeds()
            setupConnection(getPlayerObj2())
            
            task.spawn(function()
                while getgenv().EmoteSpeedSettings.Mode == "Multiplier speed" do
                    task.wait(2)
                    local current = getPlayerObj2()
                    if current ~= playerObj then
                        setupConnection(current)
                    elseif playerObj then
                        local state = playerObj:GetAttribute("State")
                        local targetSpeed = (state == "Emoting") and (getgenv().EmoteSpeedSettings.SpeedValue / 1000) or 1.5
                        applySpeedMultiplier(targetSpeed)
                    end
                end
            end)
        elseif value == "Legit" then
            resetMultiplierSpeed()
            if connection then 
                connection:Disconnect() 
                connection = nil
            end
            
            local appliedValue = getgenv().EmoteSpeedSettings.SpeedValue / 1000
            applyEmoteSpeed(appliedValue)
        end
    end
})

PlayerTab:Input({
    Title = "Emote Speed Value",
    Placeholder = tostring(getgenv().EmoteSpeedSettings.SpeedValue),
    NumbersOnly = true,
    Value = tostring(getgenv().EmoteSpeedSettings.SpeedValue),
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            getgenv().EmoteSpeedSettings.SpeedValue = num
            
            if getgenv().EmoteSpeedSettings.Mode == "Legit" then
                local appliedValue = num / 1000
                applyEmoteSpeed(appliedValue)
            elseif getgenv().EmoteSpeedSettings.Mode == "Multiplier speed" then
                if playerObj then
                    local state = playerObj:GetAttribute("State")
                    if state == "Emoting" then
                        applySpeedMultiplier(num / 1000)
                    end
                end
            end
        end
    end
})

PlayerTab:Button({
    Title = "Apply Speed to Unwalkable Emotes",
    Callback = function()
        if not itemsFolder then return end
        
        local emotesFolder = itemsFolder:FindFirstChild("Emotes")
        if not emotesFolder then return end
        
        local appliedValue = getgenv().EmoteSpeedSettings.SpeedValue / 1000
        
        for _, emoteModule in ipairs(emotesFolder:GetChildren()) do
            if emoteModule:IsA("ModuleScript") then
                local success, emoteData = pcall(require, emoteModule)
                if success and emoteData and emoteData.EmoteInfo and emoteData.EmoteInfo.SpeedMult == 0 then
                    emoteData.EmoteInfo.SpeedMult = appliedValue
                end
            end
        end
        
        getgenv().EmoteSpeedSettings.AppliedToUnwalkable = true
        
        WindUI:Notify({
            Title = "Emote Speed",
            Content = "Applied speed to unwalkable emotes",
            Duration = 3
        })
    end
})

PlayerTab:Button({
    Title = "Reset Emote Speed",
    Desc = "Having Trouble? Reset the speed or rejoin",
    Callback = function()
        restoreOriginalEmoteSpeeds()
        resetMultiplierSpeed()
        getgenv().EmoteSpeedSettings.AppliedToUnwalkable = false
        getgenv().EmoteSpeedSettings.LastAppliedValue = 0
        
        WindUI:Notify({
            Title = "Emote Speed",
            Content = "All emote speeds reset to original values",
            Duration = 3
        })
    end
})

PlayerTab:Button({
    Title = "Save Current Settings",
    Callback = function()
        WindUI:Notify({
            Title = "Emote Speed",
            Content = "Settings saved! Speed: " .. getgenv().EmoteSpeedSettings.SpeedValue .. 
                     ", Mode: " .. getgenv().EmoteSpeedSettings.Mode,
            Duration = 3
        })
    end
})

PlayerTab:Divider()

local function triggerLagSwitch()
    task.spawn(function()
        local start = tick()
        while tick() - start < getgenv().FeatureStates.LagDuration do
            for i = 1, 10000 do
                math.random(1, 1000000)
            end
        end
    end)
end

PlayerTab:Toggle({
    Title = "Lag Switch",
    Icon = "zap",
    Default = false,
    Callback = function(state)
        getgenv().FeatureStates.LagSwitchEnabled = state
        if state and not getgenv().featureToggles["Lag Switch"] then
            getgenv().featureToggles["Lag Switch"] = createFeatureToggle("Lag Switch", state, 0.35, function(newState)
                getgenv().FeatureStates.LagSwitchEnabled = newState
                if newState then
                    triggerLagSwitch()
                end
            end)
        end
        if getgenv().featureToggles["Lag Switch"] then
            getgenv().featureToggles["Lag Switch"].Gui.Enabled = state
            if getgenv().featureToggles["Lag Switch"].UpdateState then
                getgenv().featureToggles["Lag Switch"].UpdateState(state)
            end
        end
        if state then
            triggerLagSwitch()
        end
    end
})

PlayerTab:Input({
    Title = "Lag Duration (seconds)",
    Default = tostring(getgenv().FeatureStates.LagDuration),
    Placeholder = "Enter seconds",
    NumbersOnly = true,
    Callback = function(text)
        local n = tonumber(text)
        if n and n > 0 and n <= 10 then
            getgenv().FeatureStates.LagDuration = n
        end
    end
})

getgenv().AutoCarryConnection = nil
local InteractRemote = ReplicatedStorage:WaitForChild("Events"):WaitForChild("Character"):WaitForChild("Interact", 10)

local function startAutoCarry()
    if getgenv().AutoCarryConnection then return end
    
    getgenv().AutoCarryConnection = RunService.Heartbeat:Connect(function()
        if not getgenv().FeatureStates.AutoCarry then return end
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp and InteractRemote then
            for _, other in ipairs(Players:GetPlayers()) do
                if other ~= LocalPlayer and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
                    local dist = (hrp.Position - other.Character.HumanoidRootPart.Position).Magnitude
                    if dist <= 20 then
                        local args = { "Carry", [3] = other.Name }
                        pcall(function()
                            InteractRemote:FireServer(unpack(args))
                        end)
                        task.wait(0.01)
                    end
                end
            end
        end
    end)
end

local function stopAutoCarry()
    if getgenv().AutoCarryConnection then
        getgenv().AutoCarryConnection:Disconnect()
        getgenv().AutoCarryConnection = nil
    end
end

AutoTab:Toggle({
    Title = "Auto Carry",
    Value = false,
    Callback = function(state)
        getgenv().FeatureStates.AutoCarry = state
        if state then
            startAutoCarry()
            if not getgenv().featureToggles["Auto Carry"] then
                getgenv().featureToggles["Auto Carry"] = createFeatureToggle("Auto Carry", state, 0.2, function(newState)
                    getgenv().FeatureStates.AutoCarry = newState
                    if newState then
                        startAutoCarry()
                    else
                        stopAutoCarry()
                    end
                end)
            end
        else
            stopAutoCarry()
        end
        
        if getgenv().featureToggles["Auto Carry"] then
            getgenv().featureToggles["Auto Carry"].Gui.Enabled = state
            if getgenv().featureToggles["Auto Carry"].UpdateState then
                getgenv().featureToggles["Auto Carry"].UpdateState(state)
            end
        end
    end
})

AutoTab:Divider()

getgenv().InstantReviveEnabled = false
getgenv().InstantReviveDelay = 0.15
getgenv().InstantReviveConnection = nil

local function isPlayerDowned(player)
    if not player or not player.Character then return false end
    return player.Character:GetAttribute("Downed") == true
end

local function startInstantRevive()
    if getgenv().InstantReviveConnection then return end
    
    getgenv().InstantReviveConnection = RunService.Heartbeat:Connect(function()
        if not getgenv().InstantReviveEnabled then return end
        
        local character = LocalPlayer.Character
        if not character then return end
        
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        local state = character:GetAttribute("State")
        local isEmoting = state and string.find(state, "Emoting")
        
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and isPlayerDowned(player) and player.Character then
                local targetHrp = player.Character:FindFirstChild("HumanoidRootPart")
                if targetHrp then
                    local distance = (hrp.Position - targetHrp.Position).Magnitude
                    if distance <= 15 then
                        pcall(function()
                            ReplicatedStorage.Events.Character.Interact:FireServer("Revive", true, player.Name)
                        end)
                        task.wait(getgenv().InstantReviveDelay)
                    end
                end
            end
        end
    end)
end

local function stopInstantRevive()
    if getgenv().InstantReviveConnection then
        getgenv().InstantReviveConnection:Disconnect()
        getgenv().InstantReviveConnection = nil
    end
end

AutoTab:Toggle({
    Title = "Instant Revive While Emoting",
    Value = false,
    Callback = function(state)
        getgenv().FeatureStates.InstantReviveEnabled = state
        getgenv().InstantReviveEnabled = state
        
        if state then
            startInstantRevive()
        else
            stopInstantRevive()
        end
    end
})

AutoTab:Slider({
    Title = "Revive Delay",
    Desc = "Delay between revives",
    Value = { Min = 0, Max = 1, Default = 0.15 },
    Callback = function(value)
        getgenv().FeatureStates.InstantReviveDelay = value
        getgenv().InstantReviveDelay = value
    end
})

local lastSavedPosition = nil
local respawnConnection = nil
local AutoSelfReviveConnection = nil
local hasRevived = false

local function reviveAtSpawnpoint()
    if not hasRevived then
        hasRevived = true
        task.wait(3)
        pcall(function()
            ReplicatedStorage.Events.Player.ChangePlayerMode:FireServer(true)
        end)
        task.delay(10, function()
            hasRevived = false
        end)
    end
end

local function reviveAtPosition(character, hrp)
    if hrp then
        lastSavedPosition = hrp.Position
    end
    task.wait(3)
    
    local startTime = tick()
    repeat
        pcall(function()
            ReplicatedStorage.Events.Player.ChangePlayerMode:FireServer(true)
        end)
        task.wait(0.5)
    until not character:GetAttribute("Downed") or (tick() - startTime > 2)
    
    local newCharacter = LocalPlayer.Character
    local attempts = 0
    while (not newCharacter or not newCharacter:FindFirstChild("HumanoidRootPart")) and attempts < 20 do
        newCharacter = LocalPlayer.Character
        task.wait(0.1)
        attempts = attempts + 1
    end
    
    local newHRP = newCharacter and newCharacter:FindFirstChild("HumanoidRootPart")
    if lastSavedPosition and newHRP then
        newHRP.CFrame = CFrame.new(lastSavedPosition)
        task.wait(0.1)
        local movedDistance = (newHRP.Position - lastSavedPosition).Magnitude
        if movedDistance > 5 then
            lastSavedPosition = nil
        end
    end
end

AutoTab:Toggle({
    Title = "Auto Self Revive",
    Value = false,
    Callback = function(state)
        getgenv().FeatureStates.AutoSelfRevive = state
        
        if AutoSelfReviveConnection then
            AutoSelfReviveConnection:Disconnect()
            AutoSelfReviveConnection = nil
        end
        
        if respawnConnection then
            respawnConnection:Disconnect()
            respawnConnection = nil
        end
        
        if not state then
            hasRevived = false
            lastSavedPosition = nil
            return
        end
        
        local function setupReviveLogic(character)
            if not character then return end
            
            AutoSelfReviveConnection = character:GetAttributeChangedSignal("Downed"):Connect(function()
                if not getgenv().FeatureStates.AutoSelfRevive then return end
                
                local isDowned = character:GetAttribute("Downed")
                if isDowned then
                    local hrp = character:FindFirstChild("HumanoidRootPart")
                    if getgenv().FeatureStates.SelfReviveMethod == "Spawnpoint" then
                        reviveAtSpawnpoint()
                    elseif getgenv().FeatureStates.SelfReviveMethod == "Fake Revive" then
                        reviveAtPosition(character, hrp)
                    end
                end
            end)
        end
        
        local currentChar = LocalPlayer.Character
        if currentChar then
            setupReviveLogic(currentChar)
        end
        
        respawnConnection = LocalPlayer.CharacterAdded:Connect(function(newChar)
            task.wait(1)
            setupReviveLogic(newChar)
        end)
    end
})

AutoTab:Dropdown({
    Title = "Self Revive Method",
    Values = {"Spawnpoint", "Fake Revive"},
    Value = "Spawnpoint",
    Callback = function(value)
        getgenv().FeatureStates.SelfReviveMethod = value
    end
})

local function manualRevive()
    local character = LocalPlayer.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local isDowned = character:GetAttribute("Downed")
    if not isDowned then return end
    
    if getgenv().FeatureStates.SelfReviveMethod == "Spawnpoint" then
        if not hasRevived then
            hasRevived = true
            pcall(function()
                ReplicatedStorage.Events.Player.ChangePlayerMode:FireServer(true)
            end)
            task.delay(10, function()
                hasRevived = false
            end)
        end
    elseif getgenv().FeatureStates.SelfReviveMethod == "Fake Revive" then
        if hrp then
            lastSavedPosition = hrp.Position
        end
        task.spawn(function()
            pcall(function()
                ReplicatedStorage.Events.Player.ChangePlayerMode:FireServer(true)
            end)
            
            local newCharacter
            local attempts = 0
            repeat
                newCharacter = LocalPlayer.Character
                task.wait(0.1)
                attempts = attempts + 1
            until (newCharacter and newCharacter:FindFirstChild("HumanoidRootPart") and newCharacter ~= character) or attempts >= 20
            
            if newCharacter then
                local newHRP = newCharacter:FindFirstChild("HumanoidRootPart")
                if lastSavedPosition and newHRP then
                    newHRP.CFrame = CFrame.new(lastSavedPosition)
                end
            end
        end)
    end
end

AutoTab:Button({
    Title = "Manual Revive",
    Desc = "Manually revive yourself",
    Icon = "heart",
    Callback = manualRevive
})

AutoTab:Divider()

getgenv().AntiAFK = {
    Enabled = false,
    Connection = nil
}

local virtualUser = game:GetService("VirtualUser")

local function startAntiAFK()
    if getgenv().AntiAFK.Connection then
        getgenv().AntiAFK.Connection:Disconnect()
        getgenv().AntiAFK.Connection = nil
    end
    
    getgenv().AntiAFK.Connection = LocalPlayer.Idled:Connect(function()
        virtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
        task.wait(1)
        virtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
    end)
    
    getgenv().AntiAFK.Enabled = true
end

local function stopAntiAFK()
    if getgenv().AntiAFK.Connection then
        getgenv().AntiAFK.Connection:Disconnect()
        getgenv().AntiAFK.Connection = nil
    end
    
    getgenv().AntiAFK.Enabled = false
end

AutoTab:Toggle({
    Title = "Anti AFK",
    Desc = "Prevents getting kicked for inactivity",
    Value = getgenv().AntiAFK.Enabled,
    Callback = function(state)
        if state then
            startAntiAFK()
        else
            stopAntiAFK()
        end
    end
})

LocalPlayer.CharacterAdded:Connect(function()
    if getgenv().AntiAFK.Enabled then
        task.wait(1)
        startAntiAFK()
    end
end)

game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == LocalPlayer then
        stopAntiAFK()
    end
end)

getgenv().AutoTicketFarmConnection = nil

local function startAutoTicketFarm()
    local securityPart = workspace:FindFirstChild("SecurityPart")
    if not securityPart then
        print("SecurityPart not found")
        return
    end
    
    getgenv().AutoTicketFarmConnection = RunService.Heartbeat:Connect(function()
        if not getgenv().FeatureStates.AutoTicketFarm then
            if getgenv().AutoTicketFarmConnection then
                getgenv().AutoTicketFarmConnection:Disconnect()
                getgenv().AutoTicketFarmConnection = nil
            end
            return
        end
        
        local character = LocalPlayer.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
        local tickets = workspace:FindFirstChild("Game") and 
                       workspace.Game:FindFirstChild("Effects") and 
                       workspace.Game.Effects:FindFirstChild("Tickets")
        
        if character and humanoidRootPart then
            if character:GetAttribute("Downed") then
                ReplicatedStorage.Events.Player.ChangePlayerMode:FireServer(true)
                humanoidRootPart.CFrame = securityPart.CFrame + Vector3.new(0, 0, 0)
                return
            end
            
            if tickets then
                local activeTickets = tickets:GetChildren()
                if #activeTickets > 0 then
                    local ticketPart = activeTickets[1]:FindFirstChild("HumanoidRootPart")
                    if ticketPart then
                        local targetPosition = ticketPart.Position + Vector3.new(0, 0, 0)
                        humanoidRootPart.CFrame = CFrame.new(targetPosition)
                    end
                else
                    humanoidRootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
                end
            else
                humanoidRootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end)
end

local function stopAutoTicketFarm()
    if getgenv().AutoTicketFarmConnection then
        getgenv().AutoTicketFarmConnection:Disconnect()
        getgenv().AutoTicketFarmConnection = nil
    end
    
    local character = LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    local securityPart = workspace:FindFirstChild("SecurityPart")
    if humanoidRootPart and securityPart then
        humanoidRootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
    end
end

AutoTab:Toggle({
    Title = "Auto Ticket Farm",
    Desc = "Auto farm tickets",
    Value = false,
    Callback = function(state)
        getgenv().FeatureStates.AutoTicketFarm = state
        if state then
            startAutoTicketFarm()
        else
            stopAutoTicketFarm()
        end
    end
})

local function startAutoMoneyFarm()
    local securityPart = workspace:FindFirstChild("SecurityPart")
    if not securityPart then
        getgenv().WindUI:Notify({
            Title = "Auto Money Farm",
            Content = "SecurityPart not found!",
            Duration = 3
        })
        return
    end
    
    if getgenv().AutoMoneyFarmConnection then
        getgenv().AutoMoneyFarmConnection:Disconnect()
        getgenv().AutoMoneyFarmConnection = nil
    end
    
    getgenv().AutoMoneyFarmConnection = RunService.Heartbeat:Connect(function()
        if not getgenv().FeatureStates.AutoMoneyFarm then return end
        
        local character = LocalPlayer.Character
        if not character then return end
        
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        if character:GetAttribute("Downed") then
            ReplicatedStorage.Events.Player.ChangePlayerMode:FireServer(true)
            task.wait(2)
            return
        end
        
        local downedPlayerFound = false
        local playersInGame = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
        
        if playersInGame then
            for _, playerModel in ipairs(playersInGame:GetChildren()) do
                if not playerModel:IsA("Model") then continue end
                if playerModel.Name == LocalPlayer.Name then continue end
                
                local isDowned = playerModel:GetAttribute("Downed")
                if isDowned == true then
                    local targetHRP = playerModel:FindFirstChild("HumanoidRootPart")
                    if not targetHRP then continue end
                    
                    local distance = (rootPart.Position - targetHRP.Position).Magnitude
                    if distance > 50 then
                        rootPart.CFrame = targetHRP.CFrame + Vector3.new(0, 3, 0)
                        task.wait(0.5)
                    end
                    
                    pcall(function()
                        ReplicatedStorage.Events.Character.Interact:FireServer("Revive", true, playerModel.Name)
                    end)
                    
                    downedPlayerFound = true
                    break
                end
            end
        end
        
        if not downedPlayerFound then
            local currentPos = rootPart.Position
            local securityPos = securityPart.Position
            local distanceToSecurity = (currentPos - securityPos).Magnitude
            
            if distanceToSecurity > 10 then
                rootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end)
end

local function stopAutoMoneyFarm()
    if getgenv().AutoMoneyFarmConnection then
        getgenv().AutoMoneyFarmConnection:Disconnect()
        getgenv().AutoMoneyFarmConnection = nil
    end
    
    local character = LocalPlayer.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    local securityPart = workspace:FindFirstChild("SecurityPart")
    
    if rootPart and securityPart then
        rootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
    end
end

AutoTab:Toggle({
    Title = "Auto Money Farm",
    Desc = "Auto revive players for money",
    Value = false,
    Callback = function(state)
        getgenv().FeatureStates.AutoMoneyFarm = state
        
        if state and not getgenv().featureToggles["Auto Money Farm"] then
            getgenv().featureToggles["Auto Money Farm"] = createFeatureToggle("Auto Money Farm", state, 0.4, function(newState)
                getgenv().FeatureStates.AutoMoneyFarm = newState
                if newState then
                    startAutoMoneyFarm()
                else
                    stopAutoMoneyFarm()
                end
            end)
        end
        
        if getgenv().featureToggles["Auto Money Farm"] then
            getgenv().featureToggles["Auto Money Farm"].Gui.Enabled = state
            if getgenv().featureToggles["Auto Money Farm"].UpdateState then
                getgenv().featureToggles["Auto Money Farm"].UpdateState(state)
            end
        end
        
        if state then
            startAutoMoneyFarm()
        else
            stopAutoMoneyFarm()
        end
    end
})

FPSTab:Divider()

FPSTab:Toggle({
    Title = "full bright",
    Desc = "not mine.",
    Callback = function()
        local Lighting = game:GetService("Lighting")

        -- Adjust lighting to be bright
        Lighting.Ambient = Color3.new(1,1,1)
        Lighting.OutdoorAmbient = Color3.new(1,1,1)
        Lighting.Brightness = 3
        Lighting.ExposureCompensation = 1

        -- Turn off shadows
        Lighting.GlobalShadows = false

        -- Remove dark effects
        for _, v in pairs(Lighting:GetChildren()) do
            if v:IsA("ColorCorrectionEffect")
            or v:IsA("DepthOfFieldEffect")
            or v:IsA("BloomEffect")
            or v:IsA("SunRaysEffect")
            or v:IsA("Atmosphere")
            or v:IsA("Sky") then
                v:Destroy()
            end
        end
    end
})

FPSTab:Button({
    Title = "Anti lag 1",
    Callback = function()
        local Lighting = game:GetService("Lighting")
        local Terrain = workspace:FindFirstChildOfClass("Terrain")
        local Players = game:GetService("Players")

        Lighting.GlobalShadows = false
        Lighting.FogEnd = 1e10
        Lighting.Brightness = 1

        if Terrain then
            Terrain.WaterWaveSize = 0
            Terrain.WaterWaveSpeed = 0
            Terrain.WaterReflectance = 0
            Terrain.WaterTransparency = 1
        end

        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") then
                obj.Material = Enum.Material.Plastic
                obj.Reflectance = 0
            elseif obj:IsA("Decal") or obj:IsA("Texture") then
                obj:Destroy()
            elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
                obj:Destroy()
            elseif obj:IsA("PointLight") or obj:IsA("SpotLight") or obj:IsA("SurfaceLight") then
                obj:Destroy()
            end
        end

        for _, player in ipairs(Players:GetPlayers()) do
            local char = player.Character
            if char then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("Accessory") or part:IsA("Clothing") then
                        part:Destroy()
                    end
                end
            end
        end
    end
})

FPSTab:Button({
    Title = "Reduce Graphics 1",
    Desc = "All parts smooth, disable particles and trails",
    Icon = "image-off",
    Callback = function()
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") then
                obj.Material = Enum.Material.SmoothPlastic
                obj.Reflectance = 0
            elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
                obj.Enabled = false
            end
        end
    end
})

FPSTab:Button({
    Title = "Optimize Graphics 2",
    Desc = "Smoother + Remove fog and effects",
    Callback = function()
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") then
                obj.Material = Enum.Material.SmoothPlastic
                obj.Reflectance = 0
            elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
                obj.Enabled = false
            elseif obj:IsA("Decal") or obj:IsA("Texture") then
                obj:Destroy()
            end
        end

        local Lighting = game:GetService("Lighting")
        Lighting.FogEnd = 100000
        Lighting.FogStart = 0
        Lighting.GlobalShadows = false
        
        getgenv().WindUI:Notify({
            Title = "Graphics Optimized",
            Content = "V.2 optimization applied successfully",
            Duration = 3
        })
    end
})

local function optimizeGraphics()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") then
            pcall(function()
                obj.Material = Enum.Material.SmoothPlastic
                obj.Reflectance = 0
                obj.CastShadow = false
            end)
        elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
            pcall(function()
                obj.Enabled = false
            end)
        elseif obj:IsA("Decal") then
            pcall(function()
                obj.Transparency = 1
            end)
        elseif obj:IsA("MeshPart") then
            pcall(function()
                obj.RenderFidelity = Enum.RenderFidelity.Performance
            end)
        end
    end
    
    local lighting = game:GetService("Lighting")
    pcall(function()
        lighting.GlobalShadows = false
        lighting.FogEnd = 100000
        lighting.Brightness = 2
        lighting.Outlines = false
        lighting.Technology = Enum.Technology.Voxel
    end)
    
    workspace.DescendantAdded:Connect(function(obj)
        if obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
            task.wait(0.1)
            pcall(function()
                obj.Enabled = false
            end)
        end
    end)
end

local function optimizeNetwork()
    settings().Physics.AllowSleep = true
    settings().Network.IncomingReplicationLag = 0
    game:GetService("NetworkClient"):SetOutgoingKBPSLimit(math.huge)
end

local function cleanWorkspace()
    for _, obj in ipairs(workspace:GetChildren()) do
        if obj:IsA("Model") and obj.Name == "Debris" then
            obj:Destroy()
        elseif obj:IsA("BasePart") and obj.Transparency > 0.8 then
            obj:Destroy()
        end
    end
end

FPSTab:Button({
    Title = "Fix Lag & Optimize",
    Desc = "Reduces graphics, optimizes network, cleans workspace",
    Icon = "zap",
    Callback = function()
        optimizeGraphics()
        optimizeNetwork()
        cleanWorkspace()
        
        getgenv().WindUI:Notify({
            Title = "âœ… Lag Fix Applied",
            Content = "Game performance optimized",
            Duration = 3
        })
    end
})

FPSTab:Button({
    Title = "Auto-Optimize New Objects",
    Desc = "Automatically optimize new particles/debris",
    Default = false,
    Callback = function(state)
        if state then
            workspace.DescendantAdded:Connect(function(obj)
                if obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
                    task.wait(0.1)
                    pcall(function()
                        obj.Enabled = false
                    end)
                end
            end)
        end
    end
})

FPSTab:Toggle({
    Title = "FPS Boost",
    Desc = "Reduce quality for maximum FPS",
    Default = false,
    Callback = function(state)
        local RunService = game:GetService("RunService")
        local UserGameSettings = UserSettings():GetService("UserGameSettings")
        
        if state then
            pcall(function()
                for i = 1, 10 do
                    UserGameSettings:SetQualityLevel(i)
                end
                UserGameSettings:SetQualityLevel(1)
            end)
            
            RunService:Set3dRenderingEnabled(false)
            
            settings().Physics.DeterministicInterpolationStyle = Enum.DeterministicInterpolationStyle.Disabled
        else
            RunService:Set3dRenderingEnabled(true)
            pcall(function()
                UserGameSettings:SetQualityLevel(5)
            end)
        end
    end
})

getgenv().espObjects = {}
getgenv().espThreads = {}

local function createESP(part, name, baseColor)
    if getgenv().espObjects[part] then return getgenv().espObjects[part] end
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = name .. "ESP"
    billboard.Adornee = part
    billboard.Size = UDim2.new(0, 180, 0, 40)
    billboard.StudsOffset = Vector3.new(0, 3.5, 0)
    billboard.AlwaysOnTop = true
    billboard.LightInfluence = 0
    billboard.MaxDistance = 500
    billboard.Parent = PlayerGui
    
    local label = Instance.new("TextLabel")
    label.Name = "Label"
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.TextStrokeTransparency = 0.25
    label.TextSize = 14
    label.Font = Enum.Font.GothamSemibold
    label.Text = ""
    label.TextColor3 = baseColor or Color3.fromRGB(255, 255, 255)
    label.Parent = billboard
    
    getgenv().espObjects[part] = {billboard = billboard, label = label, type = name}
    return getgenv().espObjects[part]
end

local function removeESP(part)
    if getgenv().espObjects[part] then
        getgenv().espObjects[part].billboard:Destroy()
        getgenv().espObjects[part] = nil
    end
end

local function cleanupESP()
    for part, data in pairs(getgenv().espObjects) do
        if data and data.billboard then
            data.billboard:Destroy()
        end
    end
    getgenv().espObjects = {}
    
    for name, thread in pairs(getgenv().espThreads) do
        if thread then
            coroutine.close(thread)
            getgenv().espThreads[name] = nil
        end
    end
end

EspTab:Toggle({
    Title = "Esp Player",
    Value = false,
    Callback = function(state)
        getgenv().FeatureStates.EspPlayer = state
        
        if getgenv().espThreads["player"] then
            coroutine.close(getgenv().espThreads["player"])
            getgenv().espThreads["player"] = nil
        end
        
        for part, data in pairs(getgenv().espObjects) do
            if data and data.type == "Player" then
                removeESP(part)
            end
        end
        
        if not state then return end
        
        getgenv().espThreads["player"] = coroutine.create(function()
            local function getDistance(pos)
                local char = LocalPlayer.Character
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                return hrp and (pos - hrp.Position).Magnitude or 0
            end
            
            while getgenv().FeatureStates.EspPlayer do
                local folder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
                if folder then
                    for _, char in ipairs(folder:GetChildren()) do
                        if not char:IsA("Model") then continue end
                        if char:GetAttribute("Team") == "Nextbot" then continue end
                        if char.Name == LocalPlayer.Name then continue end
                        
                        local hrp = char:FindFirstChild("HumanoidRootPart")
                        if not hrp then continue end
                        
                        local espData = getgenv().espObjects[hrp]
                        if not espData then
                            espData = createESP(hrp, "Player", Color3.fromRGB(100, 180, 255))
                        end
                        
                        if not espData or not espData.billboard or not espData.billboard.Parent then
                            getgenv().espObjects[hrp] = nil
                            continue
                        end
                        
                        local dist = getDistance(hrp.Position)
                        local downed = char:GetAttribute("Downed")
                        local downedTime = tonumber(char:GetAttribute("DownedTimeLeft")) or 0
                        
                        local displayText, color
                        if downed == true then
                            color = Color3.fromRGB(255, 60, 60)
                            displayText = string.format('%s (Downed %.0f)', char.Name, downedTime)
                        elseif downed == false then
                            color = Color3.fromRGB(100, 255, 100)
                            displayText = string.format('%s\n%.0f studs', char.Name, dist)
                        else
                            color = Color3.fromRGB(100, 180, 255)
                            displayText = string.format('%s\n%.0f studs', char.Name, dist)
                        end
                        
                        espData.label.Text = displayText
                        espData.label.TextColor3 = color
                    end
                end
                task.wait(0.3)
            end
        end)
        
        coroutine.resume(getgenv().espThreads["player"])
    end
})

EspTab:Toggle({
    Title = "Esp Ticket",
    Value = false,
    Callback = function(state)
        getgenv().FeatureStates.EspTicket = state
        
        if getgenv().espThreads["ticket"] then
            coroutine.close(getgenv().espThreads["ticket"])
            getgenv().espThreads["ticket"] = nil
        end
        
        for part, data in pairs(getgenv().espObjects) do
            if data and data.type == "Ticket" then
                removeESP(part)
            end
        end
        
        if not state then return end
        
        getgenv().espThreads["ticket"] = coroutine.create(function()
            local function getDistance(pos)
                local char = LocalPlayer.Character
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                return hrp and (pos - hrp.Position).Magnitude or 0
            end
            
            while getgenv().FeatureStates.EspTicket do
                local ticketFolder = workspace:FindFirstChild("Game") and 
                                   workspace.Game:FindFirstChild("Effects") and 
                                   workspace.Game.Effects:FindFirstChild("Tickets")
                
                if ticketFolder then
                    for _, ticketModel in ipairs(ticketFolder:GetChildren()) do
                        if not ticketModel:IsA("Model") then continue end
                        
                        local part = ticketModel:FindFirstChildWhichIsA("BasePart")
                        if not part then continue end
                        
                        local espData = getgenv().espObjects[part]
                        if not espData then
                            espData = createESP(part, "Ticket", Color3.fromRGB(255, 255, 100))
                        end
                        
                        if not espData or not espData.billboard or not espData.billboard.Parent then
                            getgenv().espObjects[part] = nil
                            continue
                        end
                        
                        local dist = getDistance(part.Position)
                        espData.label.Text = string.format("%s\n%.0f studs", ticketModel.Name, dist)
                    end
                end
                task.wait(0.3)
            end
        end)
        
        coroutine.resume(getgenv().espThreads["ticket"])
    end
})

EspTab:Toggle({
    Title = "Esp Nextbot",
    Value = false,
    Callback = function(state)
        getgenv().FeatureStates.EspNextbot = state
        
        if getgenv().espThreads["nextbot"] then
            coroutine.close(getgenv().espThreads["nextbot"])
            getgenv().espThreads["nextbot"] = nil
        end
        
        for part, data in pairs(getgenv().espObjects) do
            if data and data.type == "Nextbot" then
                removeESP(part)
            end
        end
        
        if not state then return end
        
        getgenv().espThreads["nextbot"] = coroutine.create(function()
            local function getDistance(pos)
                local char = LocalPlayer.Character
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                return hrp and (pos - hrp.Position).Magnitude or 0
            end
            
            while getgenv().FeatureStates.EspNextbot do
                local folder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
                if folder then
                    for _, npc in ipairs(folder:GetChildren()) do
                        if not npc:IsA("Model") then continue end
                        if npc:GetAttribute("Team") ~= "Nextbot" then continue end
                        
                        local part = npc:FindFirstChild("Root") or 
                                    npc:FindFirstChild("Head") or 
                                    npc:FindFirstChild("HumanoidRootPart") or
                                    npc:FindFirstChildWhichIsA("BasePart")
                        if not part then continue end
                        
                        local espData = getgenv().espObjects[part]
                        if not espData then
                            espData = createESP(part, "Nextbot", Color3.fromRGB(200, 100, 255))
                        end
                        
                        if not espData or not espData.billboard or not espData.billboard.Parent then
                            getgenv().espObjects[part] = nil
                            continue
                        end
                        
                        local dist = getDistance(part.Position)
                        local color = Color3.fromRGB(200, 100, 255)
                        if dist <= 60 then
                            local t = math.clamp((dist - 12) / 48, 0, 1)
                            color = Color3.new(
                                1,
                                0.235 + 0.765 * t,
                                0.235
                            )
                        end
                        
                        espData.label.Text = string.format("%s\n%.0f studs", npc.Name, dist)
                        espData.label.TextColor3 = color
                    end
                end
                task.wait(0.3)
            end
        end)
        
        coroutine.resume(getgenv().espThreads["nextbot"])
    end
})

getgenv().tracerThread = nil
getgenv().tracerLines = {}

local function cleanupTracers()
    for _, line in pairs(getgenv().tracerLines) do
        if line then
            pcall(function() line:Remove() end)
        end
    end
    getgenv().tracerLines = {}
end

EspTab:Toggle({
    Title = "Tracer Downed Players",
    Value = false,
    Callback = function(state)
        getgenv().FeatureStates.TracerDowned = state
        
        if getgenv().tracerThread then
            coroutine.close(getgenv().tracerThread)
            getgenv().tracerThread = nil
        end
        
        cleanupTracers()
        
        if not state then return end
        
        getgenv().tracerThread = coroutine.create(function()
            while getgenv().FeatureStates.TracerDowned do
                cleanupTracers()
                
                local folder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
                if folder and Camera then
                    for _, char in ipairs(folder:GetChildren()) do
                        if not char:IsA("Model") then continue end
                        if char:GetAttribute("Team") == "Nextbot" then continue end
                        if char.Name == LocalPlayer.Name then continue end
                        if char:GetAttribute("Downed") ~= true then continue end
                        
                        local hrp = char:FindFirstChild("HumanoidRootPart")
                        if not hrp then continue end
                        
                        local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
                        if onScreen then
                            local tracer = Drawing.new("Line")
                            tracer.Color = Color3.fromRGB(255, 60, 60)
                            tracer.Thickness = 1.5
                            tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                            tracer.To = Vector2.new(pos.X, pos.Y)
                            tracer.Visible = true
                            table.insert(getgenv().tracerLines, tracer)
                        end
                    end
                end
                task.wait(0.1)
            end
        end)
        
        coroutine.resume(getgenv().tracerThread)
    end
})

getgenv().GameTimerUI = {
    Enabled = false,
    Connection = nil,
    ScreenGui = nil,
    StartTime = tick()
}

local function formatTime(seconds)
    local minutes = math.floor(seconds / 60)
    local secs = math.floor(seconds % 60)
    return string.format("%02d:%02d", minutes, secs)
end

local function createTimerUI()
    if getgenv().GameTimerUI.ScreenGui then
        getgenv().GameTimerUI.ScreenGui:Destroy()
    end
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "TimersUI"
    screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    screenGui.Enabled = getgenv().GameTimerUI.Enabled
    
    local timeLabel = Instance.new("TextLabel")
    timeLabel.Name = "TimeLabel"
    timeLabel.Size = UDim2.new(0, 150, 0, 40)
    timeLabel.Position = UDim2.new(0.02, 0, 0.02, 0)
    timeLabel.BackgroundTransparency = 1
    timeLabel.Text = "Time: 0"
    timeLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    timeLabel.TextSize = 18
    timeLabel.Font = Enum.Font.Gotham
    timeLabel.TextXAlignment = Enum.TextXAlignment.Left
    timeLabel.Parent = screenGui

    local clientLabel = Instance.new("TextLabel")
    clientLabel.Name = "ClientLabel"
    clientLabel.Size = UDim2.new(0, 150, 0, 40)
    clientLabel.Position = UDim2.new(0.02, 0, 0.07, 0)
    clientLabel.BackgroundTransparency = 1
    clientLabel.Text = "Client Time: 00:00"
    clientLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    clientLabel.TextSize = 18
    clientLabel.Font = Enum.Font.Gotham
    clientLabel.TextXAlignment = Enum.TextXAlignment.Left
    clientLabel.Parent = screenGui
    
    getgenv().GameTimerUI.ScreenGui = screenGui
    getgenv().GameTimerUI.StartTime = tick()
end

local function updateTimer()
    if getgenv().GameTimerUI.Connection then
        getgenv().GameTimerUI.Connection:Disconnect()
        getgenv().GameTimerUI.Connection = nil
    end
    
    getgenv().GameTimerUI.Connection = RunService.Heartbeat:Connect(function()
        if not getgenv().GameTimerUI.ScreenGui or not getgenv().GameTimerUI.ScreenGui.Enabled then return end
        
        local statsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Stats")
        local timeLabel = getgenv().GameTimerUI.ScreenGui:FindFirstChild("TimeLabel")
        local clientLabel = getgenv().GameTimerUI.ScreenGui:FindFirstChild("ClientLabel")
        
        if timeLabel and clientLabel then
            if statsFolder then
                local timerValue = statsFolder:GetAttribute("Timer")
                timeLabel.Text = "Time: " .. (timerValue and tostring(math.floor(timerValue)) or "0")
            else
                timeLabel.Text = "Time: 0"
            end
            
            local clientTime = tick() - getgenv().GameTimerUI.StartTime
            clientLabel.Text = "Client Time: " .. formatTime(clientTime)
        end
    end)
end

createTimerUI()

VisualTab:Toggle({
    Title = "Show Game Timer",
    Desc = "Displays game timer and client time",
    Value = getgenv().GameTimerUI.Enabled,
    Callback = function(state)
        getgenv().GameTimerUI.Enabled = state
        
        if getgenv().GameTimerUI.ScreenGui then
            getgenv().GameTimerUI.ScreenGui.Enabled = state
        end
        
        if state then
            getgenv().GameTimerUI.StartTime = tick()
            updateTimer()
        else
            if getgenv().GameTimerUI.Connection then
                getgenv().GameTimerUI.Connection:Disconnect()
                getgenv().GameTimerUI.Connection = nil
            end
        end
    end
})

LocalPlayer.CharacterAdded:Connect(function()
    if getgenv().GameTimerUI.Enabled then
        getgenv().GameTimerUI.StartTime = tick()
    end
end)

game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == LocalPlayer then
        if getgenv().GameTimerUI.Connection then
            getgenv().GameTimerUI.Connection:Disconnect()
            getgenv().GameTimerUI.Connection = nil
        end
        if getgenv().GameTimerUI.ScreenGui then
            getgenv().GameTimerUI.ScreenGui:Destroy()
            getgenv().GameTimerUI.ScreenGui = nil
        end
    end
end)

local ChangeSettingRemote = ReplicatedStorage:WaitForChild("Events"):WaitForChild("Data"):WaitForChild("ChangeSetting")
local UpdatedEvent = ReplicatedStorage.Modules.Client.Settings.Updated

VisualTab:Slider({
    Title = "Field of View",
    Desc = "Adjust your field of view",
    Value = { Min = 1, Max = 270, Default = 70 },
    Callback = function(value)
        local num = tonumber(value)
        if num then
            pcall(function()
                ChangeSettingRemote:InvokeServer(2, num)
                UpdatedEvent:Fire(2, num)
            end)
        end
    end
})

VisualTab:Divider()

-- Input untuk memasukkan Music ID
VisualTab:Input({
    Title = "Music ID",
    Desc = "Masukkan ID musik dari Roblox",
    Value = "",
    PlaceholderText = "Contoh: 1837532419",
    ClearTextOnFocus = false,
    Callback = function(musicId)
        -- Validasi input
        if musicId == "" or not tonumber(musicId) then
            WindUI:Notify({
                Title = "Error",
                Content = "Masukkan ID yang valid!",
                Icon = "alert-circle",
                Duration = 3
            })
            return
        end
        
        -- Hentikan semua musik yang sedang diputar
        for _, child in pairs(game:GetService("Workspace"):GetChildren()) do
            if child:IsA("Sound") then
                child:Stop()
                child:Destroy()
            end
        end
        
        -- Buat sound object baru
        local sound = Instance.new("Sound")
        sound.Parent = game:GetService("Workspace")
        sound.SoundId = "rbxassetid://" .. musicId
        sound.Volume = 5
        sound.Looped = true
        sound:Play()
        
        -- Simpan referensi
        if not _G.CurrentMusic then
            _G.CurrentMusic = {}
        end
        _G.CurrentMusic.Sound = sound
        _G.CurrentMusic.Id = musicId
        
        WindUI:Notify({
            Title = "Music Playing",
            Content = "Memutar musik ID: " .. musicId,
            Icon = "music",
            Duration = 3
        })
    end
})

-- Button untuk menghentikan musik
VisualTab:Button({
    Title = "Stop Music",
    Desc = "Menghentikan semua musik",
    Callback = function()
        local stoppedCount = 0
        
        -- Hentikan semua sound di Workspace
        for _, child in pairs(game:GetService("Workspace"):GetChildren()) do
            if child:IsA("Sound") then
                child:Stop()
                child:Destroy()
                stoppedCount = stoppedCount + 1
            end
        end
        
        -- Reset current music
        _G.CurrentMusic = nil
        
        WindUI:Notify({
            Title = "Music Stopped",
            Content = "Menghentikan " .. stoppedCount .. " musik",
            Icon = "stop-circle",
            Duration = 3
        })
    end
})

VisualTab:Toggle({
    Title = "bypass battlepass",
    Desc = "when u buy something the battlepass get normally",
    Value = false,
    Callback = function(state)
        if state then
            local function hideBattlepass()
                local success = pcall(function()
                    local gui = LocalPlayer.PlayerGui.Menu.Views.Battlepass.ViewPass.Center.ViewPass.Unlocked
                    gui.Visible = false
                    return true
                end)
                
                if not success then
                    warn("Could not find Battlepass GUI")
                end
            end
            
            if LocalPlayer.PlayerGui:FindFirstChild("Menu") then
                task.wait(2)
                hideBattlepass()
            end
            
            local connection
            connection = LocalPlayer.PlayerGui.ChildAdded:Connect(function(child)
                if child.Name == "Menu" then
                    task.wait(2)
                    hideBattlepass()
                end
            end)
            
            FeatureStates.HideBattlepassConnection = connection
        else
            if FeatureStates.HideBattlepassConnection then
                FeatureStates.HideBattlepassConnection:Disconnect()
                FeatureStates.HideBattlepassConnection = nil
            end
            
            local success = pcall(function()
                local gui = LocalPlayer.PlayerGui.Menu.Views.Battlepass.ViewPass.Center.ViewPass.Unlocked
                gui.Visible = true
            end)
        end
    end
})

VisualTab:Divider()

VisualTab:Divider()

VisualTab:Input({
    Title = "Camera Stretch Vertical",
    Value = "0.80",
    Placeholder = "Enter vertical stretch value",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            getgenv().FeatureStates.CameraStretchVertical = num
        end
    end
})

VisualTab:Input({
    Title = "Camera Stretch Horizontal",
    Value = "0.80",
    Placeholder = "Enter horizontal stretch value",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            getgenv().FeatureStates.CameraStretchHorizontal = num
        end
    end
})

getgenv().ScreenStretchEnabled = false
getgenv().ScreenStretchVertical = 0.65
getgenv().ScreenStretchConn = nil

VisualTab:Toggle({
    Title = "Screen Stretch",
    Desc = "Adjust vertical camera scaling",
    Value = false,
    Callback = function(state)
        getgenv().ScreenStretchEnabled = state
        
        if state then
            if not getgenv().ScreenStretchConn then
                getgenv().ScreenStretchConn = RunService.RenderStepped:Connect(function()
                    if Camera and getgenv().ScreenStretchEnabled then
                        Camera.CFrame = Camera.CFrame * CFrame.new(0, 0, 0, 1, 0, 0, 0, getgenv().ScreenStretchVertical, 0, 0, 0, 1)
                    end
                end)
            end
        else
            if getgenv().ScreenStretchConn then
                getgenv().ScreenStretchConn:Disconnect()
                getgenv().ScreenStretchConn = nil
            end
        end
    end
})

VisualTab:Divider()

getgenv().HeadlessKorblox = {
    Enabled = false,
    Connections = {}
}

local HEADLESS_MESH_ID = "rbxassetid://1095708"
local KORBLOX_MESH_ID = "rbxassetid://101851696"
local KORBLOX_TEXTURE_ID = "rbxassetid://101851254"
local DARK_GREY_COLOR = Color3.fromRGB(64, 64, 64)

local function removeFace(head)
    local face = head:FindFirstChild("face")
    if face then
        face:Destroy()
    end
end

local function applyHeadless(head)
    if not head then return end

    head.Transparency = 1
    head.CanCollide = false

    removeFace(head)

    local mesh = Instance.new("SpecialMesh")
    mesh.MeshType = Enum.MeshType.FileMesh
    mesh.MeshId = HEADLESS_MESH_ID
    mesh.Scale = Vector3.new(0.001, 0.001, 0.001)
    mesh.Parent = head

    table.insert(getgenv().HeadlessKorblox.Connections, head:GetPropertyChangedSignal("Transparency"):Connect(function()
        if head.Transparency ~= 1 then
            head.Transparency = 1
        end
    end))

    table.insert(getgenv().HeadlessKorblox.Connections, head.ChildAdded:Connect(function(child)
        if child.Name == "face" and child:IsA("Decal") then
            child:Destroy()
        end
    end))
end

local function applyKorbloxR6(character)
    local rightLeg = character:FindFirstChild("Right Leg")
    if not rightLeg then return end

    for _, child in ipairs(rightLeg:GetChildren()) do
        if child:IsA("SpecialMesh") or child:IsA("CharacterMesh") then
            child:Destroy()
        end
    end

    rightLeg.Color = DARK_GREY_COLOR
    table.insert(getgenv().HeadlessKorblox.Connections, rightLeg:GetPropertyChangedSignal("Color"):Connect(function()
        if rightLeg.Color ~= DARK_GREY_COLOR then
            rightLeg.Color = DARK_GREY_COLOR
        end
    end))

    local korbloxMesh = Instance.new("SpecialMesh")
    korbloxMesh.MeshType = Enum.MeshType.FileMesh
    korbloxMesh.MeshId = KORBLOX_MESH_ID
    korbloxMesh.TextureId = KORBLOX_TEXTURE_ID
    korbloxMesh.Scale = Vector3.new(1, 1, 1)
    korbloxMesh.Parent = rightLeg
end

local function applyKorbloxR15(character)
    local rightUpperLeg = character:FindFirstChild("RightUpperLeg")
    if not rightUpperLeg then return end

    rightUpperLeg.Transparency = 1
    local rightLowerLeg = character:FindFirstChild("RightLowerLeg")
    local rightFoot = character:FindFirstChild("RightFoot")
    if rightLowerLeg then rightLowerLeg.Transparency = 1 end
    if rightFoot then rightFoot.Transparency = 1 end

    local korbloxLeg = Instance.new("Part")
    korbloxLeg.Name = "KorbloxLeg"
    korbloxLeg.Size = Vector3.new(1, 2, 1)
    korbloxLeg.Anchored = false
    korbloxLeg.CanCollide = false
    korbloxLeg.Color = DARK_GREY_COLOR
    korbloxLeg.Parent = character

    local mesh = Instance.new("SpecialMesh")
    mesh.MeshType = Enum.MeshType.FileMesh
    mesh.MeshId = KORBLOX_MESH_ID
    mesh.TextureId = KORBLOX_TEXTURE_ID
    mesh.Scale = Vector3.new(1, 1, 1)
    mesh.Parent = korbloxLeg

    local weld = Instance.new("Weld")
    weld.Part0 = rightUpperLeg
    weld.Part1 = korbloxLeg
    weld.C0 = CFrame.new(0, -0.8, 0)
    weld.Parent = korbloxLeg
end

local function applyCharacter(character)
    local head = character:FindFirstChild("Head")
    task.wait(0.1)
    if head then
        applyHeadless(head)
    end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        if humanoid.RigType == Enum.HumanoidRigType.R6 then
            applyKorbloxR6(character)
        elseif humanoid.RigType == Enum.HumanoidRigType.R15 then
            applyKorbloxR15(character)
        end
    end
end

local function cleanupConnections()
    for _, connection in ipairs(getgenv().HeadlessKorblox.Connections) do
        pcall(function()
            connection:Disconnect()
        end)
    end
    getgenv().HeadlessKorblox.Connections = {}
end

VisualTab:Toggle({
    Title = "Headless & Korblox",
    Desc = "Apply headless head and korblox leg",
    Value = getgenv().HeadlessKorblox.Enabled,
    Callback = function(state)
        getgenv().HeadlessKorblox.Enabled = state
        
        if state then
            cleanupConnections()
            
            local character = LocalPlayer.Character
            if character then
                applyCharacter(character)
            end
            
            getgenv().HeadlessKorblox.Connections[#getgenv().HeadlessKorblox.Connections + 1] = LocalPlayer.CharacterAdded:Connect(function(newCharacter)
                if getgenv().HeadlessKorblox.Enabled then
                    applyCharacter(newCharacter)
                end
            end)
            
            getgenv().HeadlessKorblox.Connections[#getgenv().HeadlessKorblox.Connections + 1] = RunService.Heartbeat:Connect(function()
                if getgenv().HeadlessKorblox.Enabled and LocalPlayer.Character then
                    applyCharacter(LocalPlayer.Character)
                end
            end)
        else
            cleanupConnections()
            
            local character = LocalPlayer.Character
            if character then
                local head = character:FindFirstChild("Head")
                if head then
                    head.Transparency = 0
                    local mesh = head:FindFirstChildOfClass("SpecialMesh")
                    if mesh then
                        mesh:Destroy()
                    end
                end
                
                local rightLeg = character:FindFirstChild("Right Leg")
                if rightLeg then
                    rightLeg.Color = Color3.fromRGB(163, 162, 165)
                    local mesh = rightLeg:FindFirstChildOfClass("SpecialMesh")
                    if mesh then
                        mesh:Destroy()
                    end
                end
                
                local korbloxLeg = character:FindFirstChild("KorbloxLeg")
                if korbloxLeg then
                    korbloxLeg:Destroy()
                end
            end
        end
    end
})

game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == LocalPlayer then
        cleanupConnections()
    end
end)

VisualTab:Toggle({
    Title = "Fix Animation Cola",
    Desc = "Fixes the cola animation glitch",
    Value = getgenv().FeatureStates.FixColaAnimation,
    Callback = function(state)
        getgenv().FeatureStates.FixColaAnimation = state
        
        if state then
            -- Terapkan hook
            local success, errorMsg = pcall(function()
                local Event = game:GetService("Players").LocalPlayer.PlayerScripts.Events.temporary_events.UseKeybind

                -- Cek apakah hook sudah ada
                if getgenv().FeatureStates.FixColaHookEnabled then
                    getgenv().WindUI:Notify({
                        Title = "Animation Fix",
                        Content = "Hook already applied!",
                        Duration = 3
                    })
                    return
                end

                local mt = getrawmetatable(Event)
                local oldNamecall = mt.__namecall

                setreadonly(mt, false)
                mt.__namecall = newcclosure(function(self, ...)
                    local method = getnamecallmethod()
                    local args = {...}
                    
                    if (method == "Fire" or method == "FireServer") and self == Event then
                        if args[1] and args[1].Key and args[1].Key == "Cola" then
                            game:GetService("ReplicatedStorage").Events.Character.ToolAction:FireServer(0,19)
                            -- Return a dummy value instead of nil
                            return wait()
                        end
                    end
                    
                    return oldNamecall(self, ...)
                end)
                setreadonly(mt, true)
                
                getgenv().FeatureStates.FixColaHookEnabled = true
                
                -- Simpan reference untuk nanti
                getgenv().ColaFixData = {
                    OldNamecall = oldNamecall,
                    Event = Event
                }
            end)
            
            if success then
                getgenv().WindUI:Notify({
                    Title = "Animation Fix",
                    Content = "Cola animation fix applied!",
                    Duration = 3
                })
            else
                getgenv().WindUI:Notify({
                    Title = "Animation Fix Error",
                    Content = "Failed to apply: " .. tostring(errorMsg),
                    Duration = 5
                })
                getgenv().FeatureStates.FixColaAnimation = false
            end
        else
            -- Nonaktifkan hook
            if getgenv().FeatureStates.FixColaHookEnabled and getgenv().ColaFixData then
                pcall(function()
                    local mt = getrawmetatable(getgenv().ColaFixData.Event)
                    setreadonly(mt, false)
                    mt.__namecall = getgenv().ColaFixData.OldNamecall
                    setreadonly(mt, true)
                end)
                
                getgenv().FeatureStates.FixColaHookEnabled = false
                getgenv().ColaFixData = nil
                
                getgenv().WindUI:Notify({
                    Title = "Animation Fix",
                    Content = "Cola animation fix removed!",
                    Duration = 3
                })
            end
        end
    end
})

game:GetService("Players").PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then
        -- ... cleanup lainnya ...
        
        -- Cleanup untuk Fix Cola Animation
        if getgenv().FeatureStates.FixColaHookEnabled and getgenv().ColaFixData then
            pcall(function()
                local mt = getrawmetatable(getgenv().ColaFixData.Event)
                setreadonly(mt, false)
                mt.__namecall = getgenv().ColaFixData.OldNamecall
                setreadonly(mt, true)
            end)
        end
        getgenv().FeatureStates.FixColaHookEnabled = false
        getgenv().ColaFixData = nil
        
        -- ... cleanup lainnya ...
    end
end)

VisualTab:Divider()

local cosmetic1, cosmetic2 = ""  
VisualTab:Space()  

local function normalize(str)    
    return str:gsub("%s+", ""):lower()    
end    

local function levenshtein(s, t)    
    local m, n = #s, #t    
    local d = {}    
    for i = 0, m do d[i] = {[0] = i} end    
    for j = 0, n do d[0][j] = j end    

    for i = 1, m do    
        for j = 1, n do    
            local cost = (s:sub(i,i) == t:sub(j,j)) and 0 or 1    
            d[i][j] = math.min(d[i-1][j] + 1, d[i][j-1] + 1, d[i-1][j-1] + cost)    
        end    
    end    
    return d[m][n]    
end    

local function similarity(s, t)    
    local nS, nT = normalize(s), normalize(t)    
    local dist = levenshtein(nS, nT)    
    return 1 - dist / math.max(#nS, #nT)    
end    

local function findSimilar(name)
    local Cosmetics = ReplicatedStorage:WaitForChild("Items"):WaitForChild("Cosmetics")
    local bestMatch = nil
    local bestScore = 0.5    
    for _, c in ipairs(Cosmetics:GetChildren()) do    
        local score = similarity(name, c.Name)    
        if score > bestScore then    
            bestScore = score    
            bestMatch = c.Name    
        end    
    end    
    return bestMatch    
end

VisualTab:Input({  
    Title = "Current Cosmetic",  
    Placeholder = "Enter Current Cosmetic",  
    Callback = function(v)
        if v == "" then
            cosmetic1 = ""
            return
        end
        
        local match = findSimilar(v)
        if match then
            cosmetic1 = match
            getgenv().WindUI:Notify({Title = "Cosmetic Changer", Content = "Current: " .. match})
            else
            cosmetic1 = ""
            getgenv().WindUI:Notify({Title = "Cosmetic Changer", Content = "This cosmetic was not found! "})
        end
    end  
})  

VisualTab:Input({  
    Title = "Select Cosmetic",  
    Placeholder = "like Toxic Inf",  
    Callback = function(v)
        if v == "" then
            cosmetic2 = ""
            return
        end
        
        local match = findSimilar(v)
        if match then
            cosmetic2 = match
            getgenv().WindUI:Notify({Title = "Cosmetic Changer", Content = "Select: " .. match})
        else
            cosmetic2 = ""
            getgenv().WindUI:Notify({Title = "Cosmetic Changer", Content = "This cosmetic was not found! "})
        end
    end  
})  

VisualTab:Button({  
    Title = "Apply ",  
    Callback = function()  
        pcall(function()  
            if cosmetic1 == "" or cosmetic2 == "" or cosmetic1 == cosmetic2 then return end  

            local Cosmetics = ReplicatedStorage:WaitForChild("Items"):WaitForChild("Cosmetics")

            local a = Cosmetics:FindFirstChild(cosmetic1)    
            local b = Cosmetics:FindFirstChild(cosmetic2)    
            if not a or not b then return end    

            local tempRoot = Instance.new("Folder", Cosmetics)    
            tempRoot.Name = "__temp_swap_" .. tostring(tick()):gsub("%.", "_")    

            local tempA = Instance.new("Folder", tempRoot)    
            local tempB = Instance.new("Folder", tempRoot)    

            for _, c in ipairs(a:GetChildren()) do c.Parent = tempA end    
            for _, c in ipairs(b:GetChildren()) do c.Parent = tempB end    

            for _, c in ipairs(tempA:GetChildren()) do c.Parent = b end    
            for _, c in ipairs(tempB:GetChildren()) do c.Parent = a end    

            tempRoot:Destroy()
            
            getgenv().WindUI:Notify({Title = "Cosmetic Changer", Content = "Applied successfully!"})
        end)    
    end  
})

VisualTab:Space()

local Events = ReplicatedStorage:WaitForChild("Events",10)
local CharacterFolder = Events:WaitForChild("Character",10)
local EmoteRemote = CharacterFolder:WaitForChild("Emote",10)
local PassCharacterInfo = CharacterFolder:WaitForChild("PassCharacterInfo",10)
local remoteSignal = PassCharacterInfo and PassCharacterInfo.OnClientEvent

getgenv().currentTag = nil
getgenv().currentEmotes = table.create(6,"")
getgenv().selectEmotes = table.create(6,"")
getgenv().emoteEnabled = table.create(6,false)
getgenv().pendingSlot = nil
getgenv().blockOriginalEmote = false
getgenv().lastNum = nil

local function levenshtein2(s1, s2)
    local len1 = #s1
    local len2 = #s2
    local matrix = {}
    
    for i = 0, len1 do
        matrix[i] = {[0] = i}
    end
    
    for j = 0, len2 do
        matrix[0][j] = j
    end
    
    for i = 1, len1 do
        for j = 1, len2 do
            local cost = (s1:sub(i,i) == s2:sub(j,j)) and 0 or 1
            matrix[i][j] = math.min(
                matrix[i-1][j] + 1,
                matrix[i][j-1] + 1,
                matrix[i-1][j-1] + cost
            )
        end
    end
    
    return matrix[len1][len2]
end

local function findBestMatch(input, emotes)
    local cleanInput = input:gsub("%s+",""):lower()
    if cleanInput == "" then return nil end
    
    local bestMatch = nil
    local bestSimilarity = 0
    
    for _, emote in ipairs(emotes:GetChildren()) do
        local emoteName = emote.Name:gsub("%s+",""):lower()
        local distance = levenshtein2(cleanInput, emoteName)
        local maxLen = math.max(#cleanInput, #emoteName)
        local similarity = 1 - (distance / maxLen)
        
        if similarity >= 0.5 and similarity > bestSimilarity then
            bestSimilarity = similarity
            bestMatch = emote.Name
        end
    end
    
    return bestMatch
end

local function setRandom()
    local c = LocalPlayer.Character
    if not c then return end
    local n = math.random(1,3)
    if n ~= getgenv().lastNum then
        getgenv().lastNum = n
        c:SetAttribute("EmoteNum",n)
    end
end

local function readTagFromFolder(f)
    if not f then return nil end
    local a = f:GetAttribute("Tag")
    if a ~= nil then return a end
    local o = f:FindFirstChild("Tag")
    if o and o:IsA("ValueBase") then return o.Value end
    return nil
end

local function onRespawn()
    getgenv().currentTag = nil
    getgenv().pendingSlot = nil
    task.spawn(function()
        local start = tick()
        while tick()-start < 10 do
            if workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players") then
                local pf = workspace.Game.Players:FindFirstChild(LocalPlayer.Name)
                if pf then
                    getgenv().currentTag = readTagFromFolder(pf)
                    if getgenv().currentTag then
                        local b = tonumber(getgenv().currentTag)
                        if b and b >= 0 and b <= 255 then break else getgenv().currentTag = nil end
                    end
                end
            end
            task.wait(0.5)
        end
    end)
end

local function fireSelect(slot)
    if not getgenv().currentTag then return end
    local b = tonumber(getgenv().currentTag)
    if not b or b < 0 or b > 255 then return end
    if not getgenv().selectEmotes[slot] or getgenv().selectEmotes[slot] == "" then return end
    local buf = buffer.create(2)
    buffer.writeu8(buf,0,b)
    buffer.writeu8(buf,1,17)
    if remoteSignal then
        firesignal(remoteSignal,buf,{getgenv().selectEmotes[slot]})
    end
end

local oldNamecall
oldNamecall = hookmetamethod(game,"__namecall",function(self,...)
    local method = getnamecallmethod()
    local args = {...}

    if method == "FireServer" and self == EmoteRemote and type(args[1]) == "string" then
        for i = 1,6 do
            if getgenv().emoteEnabled[i] and getgenv().currentEmotes[i] ~= "" and args[1] == getgenv().currentEmotes[i] then
                getgenv().pendingSlot = i
                getgenv().blockOriginalEmote = true
                setRandom()

                task.spawn(function()
                    task.wait(0.1)
                    getgenv().blockOriginalEmote = false
                    if getgenv().pendingSlot == i then
                        getgenv().pendingSlot = nil
                        fireSelect(i)
                    end
                end)

                if getgenv().blockOriginalEmote then
                    return nil
                end
            end
        end
    end

    return oldNamecall(self,...)
end)

if LocalPlayer.Character then task.spawn(onRespawn) end
LocalPlayer.CharacterAdded:Connect(function() task.wait(1) onRespawn() end)

if workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players") then
    workspace.Game.Players.ChildAdded:Connect(function(child)
        if child.Name == LocalPlayer.Name then task.wait(0.5) onRespawn() end
    end)
    workspace.Game.Players.ChildRemoved:Connect(function(child)
        if child.Name == LocalPlayer.Name then getgenv().currentTag = nil getgenv().pendingSlot = nil end
    end)
end

local emoteFolder = ReplicatedStorage.Items.Emotes

for i = 1,6 do
    VisualTab:Input({
        Title = "Current Emote "..i,
        Placeholder = "Enter current emote name",
        Value = getgenv().currentEmotes[i],
        Callback = function(v)
            if v == "" then
                getgenv().currentEmotes[i] = ""
                return
            end
            
            local match = findBestMatch(v, emoteFolder)
            if match then
                getgenv().currentEmotes[i] = match
                getgenv().WindUI:Notify({Title = "Emote Changer",Content = "Current "..i..": "..match})
            else
                getgenv().currentEmotes[i] = ""
                getgenv().WindUI:Notify({Title = "Emote Changer",Content = "This emote was not found! "..i})
            end
        end
    })

    VisualTab:Input({
        Title = "Select Emote "..i,
        Placeholder = "Enter select emote name",
        Value = getgenv().selectEmotes[i],
        Callback = function(v)
            if v == "" then
                getgenv().selectEmotes[i] = ""
                return
            end
            
            local match = findBestMatch(v, emoteFolder)
            if match then
                getgenv().selectEmotes[i] = match
                getgenv().WindUI:Notify({Title = "Emote Changer",Content = "Select "..i..": "..match})
            else
                getgenv().selectEmotes[i] = ""
                getgenv().WindUI:Notify({Title = "Emote Changer",Content = "This emote was not found! "..i})
            end
        end
    })

    VisualTab:Button({
        Title = "Apply "..i,
        Icon = "solar:arrow-right-line-duotone",
        Callback = function()
            getgenv().emoteEnabled[i] = (getgenv().currentEmotes[i] ~= "" and getgenv().selectEmotes[i] ~= "")
            getgenv().WindUI:Notify({Title = "Emote Changer",Content = "Slot "..i.." applied!"})
        end
    })

    VisualTab:Divider()
end

VisualTab:Button({
    Title = "Reset All Emotes",
    Icon = "solar:trash-bin-2-linear",
    Callback = function()
        for i = 1,6 do
            getgenv().currentEmotes[i] = ""
            getgenv().selectEmotes[i] = ""
            getgenv().emoteEnabled[i] = false
        end
        getgenv().WindUI:Notify({Title = "Emote Changer",Content = "All emotes reset!"})
    end
})

VisualTab:Divider()

VisualTab:Input({
    Title = "Fake Streaks",
    Placeholder = "Enter streak value",
    Callback = function(value)
        local num = tonumber(value)
        if num then
            pcall(function()
                LocalPlayer:SetAttribute("Streak", num)
                getgenv().WindUI:Notify({
                    Title = "Streak",
                    Content = string.format("Streak set to %d", num),
                    Duration = 3
                })
            end)
        end
    end
})

SettingsTab:Section({Title = "Settings"})

local themeValues = {}
for name, _ in pairs(getgenv().WindUI:GetThemes()) do
    table.insert(themeValues, name)
end

local themeDropdown = SettingsTab:Dropdown({
    Title = "Select Theme",
    Multi = false,
    AllowNone = false,
    Values = themeValues,
    Callback = function(theme)
        getgenv().WindUI:SetTheme(theme)
    end
})

themeDropdown:Select(getgenv().WindUI:GetCurrentTheme())

local currentBackground = "rbxassetid://85878831310179"

local function applyBackground(value)
    if value:match("^https?://") and value:match("%.webm") then
        currentBackground = "video:" .. value
    elseif value:match("^video:") or value:match("^rbxassetid://") then
        currentBackground = value
    elseif value:match("^%d+$") then
        currentBackground = "rbxassetid://" .. value
    else
        currentBackground = ""
    end
    
    Window:SetBackgroundImage(currentBackground)
end

SettingsTab:Input({
    Title = "Background Image/Video",
    Value = currentBackground:match("%d+") or "",
    Placeholder = "Asset ID or Video Link",
    Callback = applyBackground
})

SettingsTab:Dropdown({
    Title = "Recommended Backgrounds",
    Values = {"85878831310179", "no Background"},
    Default = currentBackground:match("%d+"),
    Callback = applyBackground
})

SettingsTab:Button({
    Title = "Remove Background",
    Callback = function()
        applyBackground("")
    end
})

SettingsTab:Toggle({
    Title = "Toggle Window Transparency",
    Callback = function(e)
        Window:ToggleTransparency(e)
    end,
    Value = getgenv().WindUI:GetTransparency()
})

local ConfigManager = Window.ConfigManager
local myConfig = ConfigManager:CreateConfig("WeroShinyConfig")

SettingsTab:Button({
    Title = "Save Configuration",
    Callback = function()
        myConfig:Save()
        getgenv().WindUI:Notify({
            Title = "Configuration",
            Content = "Settings saved successfully!",
            Duration = 3
        })
    end
})

SettingsTab:Button({
    Title = "Load Configuration",
    Callback = function()
        myConfig:Load()
        getgenv().WindUI:Notify({
            Title = "Configuration",
            Content = "Settings loaded successfully!",
            Duration = 3
        })
    end
})

Window:SelectTab(1)

local function createSimpleTimer()
    local timerRunning = false
    local timerThread = nil
    
    local function updateTimer()
        while timerRunning do
            local statsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Stats")
            if statsFolder then
                local timerValue = statsFolder:GetAttribute("Timer")
                if timerValue then
                    local minutes = math.floor(timerValue / 60)
                    local seconds = math.floor(timerValue % 60)
                    local timeText = string.format("%d:%02d", minutes, seconds)
                end
            end
            task.wait(1)
        end
    end
    
    local function toggleTimer(state)
        timerRunning = state
        if state then
            timerThread = task.spawn(updateTimer)
        elseif timerThread then
            task.cancel(timerThread)
            timerThread = nil
        end
    end
    
    task.spawn(function()
        while true do
            if getgenv().FeatureStates.TimerDisplay then
                toggleTimer(true)
            else
                toggleTimer(false)
            end
            task.wait(0.5)
        end
    end)
end

createSimpleTimer()


WindUI:Notify({
    Title = "From SYFTA",
    Content = "ðŸŽ„MERRY CHRISTMAS ALLðŸŽ„",
    Duration = 3, -- 3 seconds
    Icon = "heart",
})
-- ================================
-- CLEANUP FOR FRONT JUMP
-- ================================
LocalPlayer.CharacterRemoving:Connect(function()
    if getgenv().frontJumpVelocity then
        getgenv().frontJumpVelocity:Destroy()
        getgenv().frontJumpVelocity = nil
    end
    getgenv().FeatureStates.FrontJumpEnabled = false
end)

game:GetService("Players").PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then
        cleanupESP()
        cleanupTracers()
        
        if getgenv().tracerThread then
            coroutine.close(getgenv().tracerThread)
        end
        
        for name, thread in pairs(getgenv().espThreads) do
            if thread then
                coroutine.close(thread)
            end
        end
        
        if getgenv().bhopConnection then
            getgenv().bhopConnection:Disconnect()
        end
        
        if getgenv().infiniteSlideHeartbeat then
            getgenv().infiniteSlideHeartbeat:Disconnect()
        end
        
        if getgenv().infiniteSlideCharacterConn then
            getgenv().infiniteSlideCharacterConn:Disconnect()
        end
        
        if respawnConnection then
            respawnConnection:Disconnect()
        end
        
        if AutoSelfReviveConnection then
            AutoSelfReviveConnection:Disconnect()
        end
        
        if getgenv().InstantReviveConnection then
            getgenv().InstantReviveConnection:Disconnect()
        end
        
        if getgenv().AutoTicketFarmConnection then
            getgenv().AutoTicketFarmConnection:Disconnect()
            getgenv().AutoTicketFarmConnection = nil
        end
        
        -- PERBAIKAN: Tambahkan 'end' yang hilang
        if getgenv().EmoteSpeedConnection then 
            getgenv().EmoteSpeedConnection:Disconnect() 
            getgenv().EmoteSpeedConnection = nil
        end
        
        if getgenv().AutoMoneyFarmConnection then
            getgenv().AutoMoneyFarmConnection:Disconnect()
            getgenv().AutoMoneyFarmConnection = nil
        end
        
        if getgenv().ScreenStretchConn then
            getgenv().ScreenStretchConn:Disconnect()
            getgenv().ScreenStretchConn = nil
        end
        
        if getgenv().AutoCarryConnection then
            getgenv().AutoCarryConnection:Disconnect()
        end
        
        -- PERBAIKAN: Gunakan 'AntiAFK' (dengan A besar)
        if getgenv().AntiAFK and getgenv().AntiAFK.Connection then
            getgenv().AntiAFK.Connection:Disconnect()
            getgenv().AntiAFK.Connection = nil
        end

        if getgenv().activeBV then
            getgenv().activeBV:Destroy()
            getgenv().activeBV = nil
        end
        
        if getgenv().GameTimerUI then
            if getgenv().GameTimerUI.Connection then
                getgenv().GameTimerUI.Connection:Disconnect()
                getgenv().GameTimerUI.Connection = nil
            end
            
            if getgenv().GameTimerUI.ScreenGui then
                getgenv().GameTimerUI.ScreenGui:Destroy()
                getgenv().GameTimerUI.ScreenGui = nil
            end
        end
        
        if getgenv().frontJumpVelocity then
            getgenv().frontJumpVelocity:Destroy()
            getgenv().frontJumpVelocity = nil
        end
        
        for _, toggle in pairs(getgenv().featureToggles) do
            if toggle and toggle.Gui then
                pcall(function()
                    toggle.Gui:Destroy()
                end)
            end
        end
    end
end)
